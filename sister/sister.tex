\documentclass[letter]{article}
% The file ijcai16.sty is the style file for IJCAI-16 (same as ijcai07.sty).
\usepackage{ijcai16}

\usepackage[T1]{fontenc}
\usepackage{flushend}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[scaled=.82]{beramono}
\usepackage[scaled=.86]{helvet}
\usepackage{booktabs}
\usepackage{bussproofs}
%\usepackage{cite}
\usepackage{color}
\usepackage{mathptmx}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{subfigure}
\usepackage{textcomp}
\usepackage{url}
\usepackage[all]{xy}

%\let\emph=\textit
%\let\em=\relax %%% avoid emphasized "et al."

\newcommand\yasx{\mskip.5mu y\mskip.5mu} %%% TYPESETTING: hack so that y is exactly as wide as x

\newcommand\DISC[1]{t \teq \const{C}_{#1}\negvthinspace\bigl(\const s^1_{#1}( t ), \ldots,\const s^{n_{#1}}_{#1}( t )\bigr)}

\newcommand\MU{\vvthinspace\mu\vvthinspace}

\theoremstyle{plain}
\newtheorem*{theoremi}{Theorem 1 (Termination)}
\newtheorem*{theoremii}{Theorem 2 (Refutation Soundness)}
\newtheorem*{theoremiii}{Theorem 3 (Solution Soundness)}

\theoremstyle{definition}
\newtheorem{examplex}{Example}%{\itshape}{\rmfamily}
\newtheorem{definition}{Definition}

\newcommand\MIDRULE{
\\[-1pt] %%% TYPESETTING HACK
\midrule
%$\enatT$
\\[-11pt] %%% TYPESETTING HACK
}

\newcommand\FV{\mathrm{FV}}

\newcommand\betweenantes{\kern1.125em}

\newcommand\afterDot{\;} %%% Too little space by default after "Lemma Foo."

\newcommand\afterLdots{\kern.1em} %% TYPESETTING

% for "bussproofs" package
\EnableBpAbbreviations
\def\ScoreOverhang{1.5pt}
\def\proofSkipAmount{\vskip 0pt}
\def\defaultHypSeparation{\hskip0.75em}

\DeclareFontFamily{OT1}{pzc}{}
\DeclareFontShape{OT1}{pzc}{m}{it}{<-> s * [1.10] pzcmi7t}{}
\DeclareMathAlphabet{\mathcalx}{OT1}{pzc}{m}{it}

\let\labelitemi=\labelitemii %% CHEAT!

\newcommand\cpp{C\nobreak\raisebox{.05ex}{+}\nobreak\raisebox{.05ex}{+}}

\newcommand\iPrime{i\vthinspace'\negvthinspace}
\newcommand\jPrime{j\vthinspace'\negvthinspace}

\newcommand\Sig{\mathrm{\Sigma}}

\newcommand\keyw[1]{\textbf{#1}}
\newcommand\const[1]{\textsf{#1}}
\newcommand\ty[1]{\textit{#1}}

\newcommand\medrightarrow{\mathrel{{{\color{black}\relbar}\kern-0.9ex\rlap{\color{white}\ensuremath{\blacksquare}}\kern-0.9ex}\joinrel{\color{black}\rightarrow}}}

\newcommand\xend{{\hfill$\scriptstyle\blacksquare$}}
\newcommand\xqed{{\hfill$\scriptstyle\square$}}

\renewcommand{\vec}[1]{\bar #1}
\newcommand{\Ec}{E}
\newcommand{\Fc}{F}
\newcommand{\tEc}{\Terms(\Ec)}
\newcommand{\tcEc}{\Terms^\infty(\Ec)}
\newcommand{\rn}[1]{\textsf{#1}}
\newcommand{\teq}{\approx}
\newcommand{\tneq}{\not\teq}
\newcommand\ROR{\betweenantes}

\newcommand{\expand}[2]{\langle \smash{#2} \rangle_{#1}}

\newcommand{\interp}[2]{#1(#2)}

\newcommand{\ec}[1]{[#1]}
\newcommand{\JJJJ}{\mathcal{\!J\!}}
\newcommand{\J}{\mathcalx{J}}
\newcommand{\Val}{\mathcalx{A}\vvthinspace}
\newcommand{\ValC}{\smash{\mathcalx{A}^\star}}
\newcommand{\Varec}[1]{\vvthinspace\widetilde{#1}\vvthinspace}
\newcommand{\VAREC}[1]{\widetilde{\vphantom{\scriptstyle x^i}\smash{#1}}}
%\newcommand{\nf}[1]{{{#1}{\downarrow}}}
\newcommand{\nf}[1]{\lfloor#1\rfloor}
\newcommand{\aequiv}{\mathrel{=_\alpha}}
\newcommand{\vsim}{\aequiv}
\newcommand{\vsimv}[1]{\mathrel{=^{#1}_\alpha}}
\newcommand{\muvar}{\mathrm{Var}} %% cf. FV

\newcommand\SSS{\mathit{S}}
\newcommand\SSSS[1]{\mathit{S}^{\,#1}}

\newcommand{\thD}{\mathcalx{DC}}

\newcommand\BAD{\mathcalx{V}}
\newcommand\Terms{\mathcalx{T}}
\newcommand\Types{\mathcalx{Y}}
\newcommand\Funcs{\mathcalx{F}}

\newcommand\Data{\Types_{\mathrm{dt}}}
\newcommand\Codata{\Types_{\mathrm{codt}}}
\newcommand\Nondata{\Types_{\mathrm{ord}}}

\newcommand\Ctr{\Funcs_{\smash{\mathrm{ctr}}}}
\newcommand\Sel{\Funcs_{\smash{\mathrm{sel}}}}
%\newcommand\Plainfuncs{\Funcs_{\mathrm{other}}}

\newcommand\vvthinspace{\kern+0.041667em}
\newcommand\vthinspace{\kern+0.083333em}
\newcommand\negvthinspace{\kern-0.083333em}
\newcommand\negvvthinspace{\kern-0.041667em}

%%% For final version as well?
\usepackage[
   a4paper,
   pdftex,
   pdftitle={A Decision Procedure for (Co)datatypes in SMT Solvers},
   pdfauthor={Andrew Reynolds and Jasmin Christian Blanchette},
   pdfkeywords={},
   pdfborder={0 0 0},
   draft=false,
   bookmarksnumbered,
   bookmarks,
   bookmarksdepth=2,
   bookmarksopenlevel=2,
   bookmarksopen]{hyperref}

\urlstyle{ttstyle}

\DeclareSymbolFont{letters}{OML}{txmi}{m}{it}

\hyphenation{data-type data-types co-data-type co-data-types isa-belle sledge-hammer
non-redun-dant counter-examples counter-example mono-morph-ize mono-morph-ized}

\begin{document}

\title{A Decision Procedure for (Co)datatypes in SMT Solvers\thanks{In memoriam Morgan Deters 1979--2015}}

\author {Andrew Reynolds \\
Department of Computer Science \\
The University of Iowa, USA
\And
Jasmin Christian Blanchette \\
Inria Nancy -- Grand Est \& LORIA \\
Villers-l\`es-Nancy, France
}

%\authorrunning {A. Reynolds \and J. C. Blanchette}

%\institute{
%Andrew Reynolds
%\at \'Ecole Polytechnique F\'ed\'erale de Lausanne (EPFL), Switzerland
%\and
%Jasmin Christian Blanchette%, funded by DFG grant \textit{Hardening the Hammer} (Ni\,491\slash 14-1)
%\at Inria \& LORIA, Nancy, France \\
%Max-Planck-Institut f\"ur Informatik, Saarbr\"ucken, Germany}

\maketitle

\begin{abstract}
Datatypes and codatatypes are useful to represent finite and potentially
infinite objects. We describe a decision procedure
to reason about such types. The procedure has been
integrated in CVC4, a modern SMT (satisfiability modulo theories)
solver, which can be used both as a constraint solver and as an
automatic theorem prover. An evaluation based on formalizations developed
in the Isabelle proof assistant demonstrates the potential of our
procedure.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

In the past decade, satisfiability modulo theories (SMT) solvers
\cite{nieuwenhuis-et-al-2006}
% \cite{ganzinger-et-al-2004}
have emerged as one of the most powerful ways to
prove theorems in first-order logic. These solvers are also useful for model
finding, or constraint solving: given a set of constraints, they can be used
to find a variable assignment that satisfy them.

A great benefit of the SMT approach is that it provides a general framework
for composing optimized decision procedures and other solvers for various
theories, including equality, linear arithmetic on $\mathbb{Z}$ and
$\mathbb{R}$, and first-order quantifiers ($\forall$,~$\exists$). In this
context, two recurrent scientific questions are:
\begin{itemize}
\item Which theories would be useful to applications?
\item Which theories can be coded efficiently in SMT solvers?
\end{itemize}

This paper suggests the following partial answer:\ freely generated algebraic
and coalgebraic datatypes---also called \emph{datatypes} and
\emph{codatatypes}, respectively.
Datatypes are ubiquitous in functional programs and formal specifications.
They are useful to represent finite data structures in computer
science but also arise in formalized mathematics.
And to represent infinite objects,
a natural choice is to turn to codatatypes,
their non-well-founded dual.
%
Despite their reputation for esotericism, codatatypes have a
role to play in computer science. For example,
Leroy's verified C compiler % Comp\-Cert
\shortcite{leroy-2009} %, the verified Java compiler Jinja\-Threads
%\cite{lochbihler-2010-jinja},
and Lochbihler's formalized Java memory model
\shortcite{lochbihler-2014-jmm} both depend on codatatypes to express infinite
processes.

Codatatypes are freely generated by their constructors, but in contrast with datatypes,
infinit\-e constructor terms are also legitimate values for codatatypes
(Section~\ref{sec:co-datatypes}). The
values of a codatatype consist of all well-typed finite \emph{and infinite} variable-free
constructor
terms, and only those. As a simple example, the codatatype specification
%
\[\keyw{codata}~\,\ty{enat} \,=\, \const{Z} \,\mid\, \const{S}(\ty{enat})\]
%
(using an ML- or Haskell-like syntax)
introduces a type that
captures the natural numbers $\const{Z}$, $\const{S}(\const{Z})$, $\const{S}(\const{S}(\const{Z}))$, $\ldots$\afterLdots{},
in unary notation, extended with an
infinite value $\infty = \const{S}(\const{S}(\const{S}(\ldots)))$.
The equation $\const{S}(\infty) \teq \infty$ holds as expected,
because both sides expand to the infinite term
$\const{S}(\const{S}(\const{S}(\ldots)))$, i.e., $\infty$.

Datatypes and codatatypes are an integral part of many proof assistants,
including Coq, Isabelle, and PVS. In recent years, datatypes
have emerged in a few automatic theorem provers as well.
In this paper, we present a
unified decision procedure for universal problems involving datatypes and codatatypes
in combination (Section~\ref{sec:the-decision-procedure}).
The procedure is described abstractly as a %tableau-like
calculus and can be composed with other theories in an SMT solver.
It generalizes the procedure by Barrett {\em et al.}\
\shortcite{barrett-et-al-2007},
which covers only datatypes.
%To our knowledge, our procedure is the first of its kind for the theory of
%codatatypes.

Datatypes and codatatypes share many properties, so it makes sense
to consider them together. There are, however, at least three important
differences.
%
First, \emph{codatatypes need not be well-founded.}
For example, the type
$$\vthinspace\keyw{codata}~\;\ty{stream}_{\vthinspace\tau} \,=\allowbreak\, \const{SCons}(\tau,\allowbreak\: \ty{stream}_{\vthinspace\tau})\vthinspace$$
of infinite sequences or streams over an element type $\tau$ is
allowed, even though it has no base case.
Second, \emph{a uniqueness rule takes the place of the acyclicity rule of datatypes.}
Cyclic constraints such as
$x \teq \const{S}(x)$ %, where $\const{C}$ is a constructor,
are unsatisfiable for datatypes,
thanks to an acyclicity rule,
but satisfiable for codatatypes. 
For the latter, a uniqueness rule ensures that two values
having the same infinite expansion must be equal; from $x
\teq \const{S}(x)$ and
$y \teq \const{S}(y)$, it deduces $x \teq y$.
These two rules cannot be finitely axiomatized, so they naturally belong in
a decision procedure.
%    * in particular, acyclicity and uniqueness are necessary for some proofs
%%      (and cannot be axiomatized finitely)
%    * and for model finding, without them we quickly get spurious models
%    * explain how finite model finding works
%(For the other (co)datatype properties---the injectivity, distinctness, and
%exhaustiveness of constructors and the selector laws---it is
%widely recognized that decision procedures can be more efficient than
%axiomatizations.)
%axiom.
%
Third, \emph{it must be possible to express cyclic values as closed terms and
to enumerate them.} %This is necessary when generating models.
The \hbox{$\mu$-binder} notation associates a name with
a subterm, making it possible to represent cyclic values.
For example,
the $\mu$-term $\const{SCons}(1,\: \MU s.\; \const{SCons}(0,\: \const{SCons}(9,\: s)))$
stands for the %lasso-shaped
sequence $1, 0, 9, 0, 9, 0, 9, \dotsc$.

%%% 1090909 is a prime number

Our procedure is implemented in the SMT solver CVC4 \cite{barrett-et-al-2011}. 
It consists of about 2000 lines of \cpp{}. % code.
%most of which are shared between datatypes and codatatypes.
%
An evaluation on %hand-crafted examples and on
problems generated from Isabelle
formalizations demonstrates its usefulness (Section~\ref{sec:evaluation}).

The original version of this paper was presented at the CADE-25 conference in
Berlin, Germany \cite{reynolds-blanchette-2015-codata}. An more comprehensive
version %, including detailed proofs,
will appear in a special issue of the
\emph{Journal of Automated Reasoning}. We refer to these for a description of
related work.
%\cite{reynolds-blanchette-201x-codata2}.

\section{%The Theory of
(Co)datatypes}
\label{sec:co-datatypes}

Our setting is a monomorphic (many-sorted) first-order logic.
We fix a signature %$\Sig = (\Types, \Funcs)$
consisting of a set of types $\Types$ and a
set of function symbols $\Funcs$\negvthinspace.
The types are partitioned into
$\Types = \Data \mathrel{\uplus} \Codata \mathrel{\uplus} \Nondata$, where $\Data$ are the
\emph{datatypes}, $\Codata$ are the \emph{codatatypes}, and $\Nondata$ are the remaining
\emph{ordinary types}.
% (which can be interpreted or not).
The function symbols are
partitioned into $\Funcs = \Ctr \mathrel{\uplus} \Sel$, where $\Ctr$ are the
\emph{constructors} and $\Sel$ are the \emph{selectors}. There is no need to
consider further function symbols because they can be abstracted away as
variables when combining theories.
%Exceptionally, it is convenient to use numeric constants ($0$, $1$, \ldots)\ 
%in
%examples.
%$\Sig$-terms are standard first-order terms
%over $\Sig$,
%without $\mu$-binders.
%(Section~\ref{sec:implementation-as-a-theory-solver-in-cvc4}).

%\paragraph{Specifications}
In an SMT problem, the signature is typically given by specifying first the
uninterpreted %ordinary
types in any order, then the (co)datatypes with their constructors
and selectors in groups of $\ell$ mutually recursive datatypes or corecursive
codatatypes, and
finally any other function symbols.

%We allow ourselves some notational parameterization
%% at the metalevel
%through subscripts---for example, $\ty{stream}_{\vthinspace\tau}$ denotes a
%family of ground types including
%$\ty{stream}_{\vthinspace\ty{int}}$, $\ty{stream}_{\vthinspace\ty{bool}}$,
%and \smash{$\ty{stream}_{\vthinspace\ty{stream}_{\vthinspace\ty{real}}}$}.

\newcommand\elll{\kern.0515ex \ell\kern.0515ex}
\newcommand\elllx{\kern.0515ex \ell\kern.0515ex}

Each (co)datatype $\delta$ is equipped with
$m \ge 1$ constructors, and each constructor %for $\delta$
takes zero or more arguments and returns a $\delta$ value.
%The argument types must be either
%ordinary, among the already known (co)datatypes, or among the (co)datatypes
%being introduced.
%
To every argument corresponds a selector. The names for the (co)data\-types, the
constructors, and the selectors must be fresh.
%distinct and different from existing names.
Schematically:
%
\[
\begin{aligned}[t]
\!(\keyw{co})\keyw{data}\;\,
  \delta_1 & {}=\, \smash{\const{C}_{11\!}(\bigl[\const{s}_{11\!}^1{:}\bigr]\vthinspace \tau_{11\!}^1, \ldots, \bigl[\const{s}_{11\!}^{n_{11\!}}{:}\bigr]\vthinspace \tau_{11\!}^{n_{11\!}})} \mid \cdots \mid \smash{\const{C}_{1m_1\!}(\ldots)} \\[+0.5\jot]
   \smash{\vdots\,\,\,} \\[-0.5\jot]
  \keyw{and}\; \,\delta_{\elllx} & =\, \smash{\const{C}_{\elll 1\!}(%\bigl[\const{s}_{\elll 1\!}^1{:}\bigr]\vthinspace \tau_{\elll 1\!}^1, \ldots, \bigl[\const{s}_{\elll 1\!}^{n_{\elll 1\!}}{:}\bigr]\vthinspace \tau_{\elll 1\!}^{n_{\elll 1\!}}
  \ldots)} \mid \cdots \mid \smash{\const{C}_{\elll m_{\elllx}\!}(\ldots)}
\end{aligned}
\]
%
with
$\smash{\const{C}_{i\negvthinspace j} : \tau_{i\negvthinspace j}^1\times\cdots\times\tau_{i\negvthinspace j}^{\,n_{\smash{i\negvthinspace j}}} \to \delta_i}$
and $\smash{\const{s}_{i\negvthinspace j}^{\,k} : \delta_i \to \tau_{i\negvthinspace j}^{\,k}}$.
%Defaults are assumed for the selector names if they are omitted.
The $\delta$ constructors and selectors are denoted by $\Ctr^\delta$ and
$\Sel^\delta$.
%
For types with several constructors, it is useful to provide discriminators
$\const{d}_{i\negvthinspace j} : \delta_i \to \ty{bool}$.
We let $\const{d}_{i\negvthinspace j}(t)$
be an abbreviation for
$t \teq \const{C}_{i\negvthinspace j}\relax(\const{s}_{i\negvthinspace j}^1(t), \ldots, \const{s}_{i\negvthinspace j}^{\,n_{\smash{{i\negvthinspace j}}}}(t)\relax)$.
%This will simplify the presentation. % of the decision procedure.

%A type $\delta$ depends on another type $\varepsilon$ if $\varepsilon$ is the
%type of an argument to one of $\delta$'s constructors. Semantically, a set of
%types is \emph{mutually} (\emph{co})\emph{recursive} if and only if the
%associated dependency graph is strongly connected.
%A type is (\emph{co})\emph{recursive} if it belongs to such a set of types.
%Types can be declared together in a mutual fashion even if they are not %actually
%mutually (co)recursive. The semantic notion is more precise and is the one %that interests
%us.

%Non(co)recursive type specifications such~as either of
%\[\begin{aligned}[t]
%      \keyw{data}~\vthinspace\ty{option}_{\vthinspace\tau\!} & \,=\, %\const{None} \,\mid\, \const{Some}(\tau) \\[-.5\jot]
%      \keyw{codata}~\vthinspace\ty{complex} & \,=\, %\const{Complex}(\const{re}{:}\; \ty{real},\; \const{im}{:}\;\ty{real})
%\end{aligned}
%\]
%are permitted.
%At the semantic level, it makes no difference whether
%such types are introduced as datatypes or as codatatypes.
%Without loss of generality, we consider that these types are datatypes
%instead of codatatypes.

%Given the specification
%
%\[\keyw{codata}\;\, \ty{stream} \,=\, \const{SCons}(\ty{int},\:\ty{stream})\]
%
%the infinite value $\const{SCons}(0, \const{SCons}(0, \ldots))$ witnesses
%nonemptiness.

%One way to characterize datatypes %semantically
%is as the initial model of the
%selector--constructor equations \cite{barrett-et-al-2007}.
%A drawback of this approach is that it does
%not naturally account for selectors applied to wrong constructors. Barrett et
%al.\ address this by parameterizing the construction by default values, but
%this gives rise to spurious equalities between unrelated terms. For example,
%given
%\[\keyw{data}\;\, \ty{x} \,=\, \const{C}(\const{s}{:}\; \ty{int}) \mid %\const{D} \mid \const{E}\]
%we would have the spurious equality
%$\const{s}(\const{D}) \teq \const{s}(\const{E})$. This flaw
%could be corrected, but the added complexity seems to suggest that selectors
%are better characterized axiomatically.
%
%A related semantic view of datatypes is as initial algebras of suitable
%functors. Codatatypes are
%then defined dually as final coalgebras \cite{rutten-2000}. The datatypes are
%generated by their constructors, whereas the codatatypes are viewed through
%their selectors.
%By uniformly focusing on the constructors, the
%axiomatic approach emphasizes the commonality between datatypes and
%codatatypes, while sacrificing a theoretically fruitful notion of duality.

Datatypes and codatatypes share many basic properties. All properties
below are implicitly universally quantified and range over all $i$, $j$,
$\jPrime$, and $k$ within bounds:
% and to all possible splits of the
%$n$-ary constructor $\const{C}_{i\negvthinspace j}$'s argument list into $\bar x,
%y, \bar z$:
%
\[
\!\begin{aligned}[t]
\text{Distinctness:}\enskip
  & %\forall \bar x, \bar y.\;\,
    \smash{\const{C}_{i\negvthinspace j}(\bar x) \tneq \const{C}_{i\negvthinspace \jPrime}(\bar y) \quad\text{if $j \not= \jPrime$}}
  \\[-0.5\jot]
\text{Injectivity:}\enskip
  & %\forall x_1,\ldots,x_{n_{i\negvthinspace j}} y.\;\,
    \smash{\const{C}_{i\negvthinspace j}(x_1,\ldots,x_{n_{i\negvthinspace j}}) \teq \const{C}_{i\negvthinspace j}(y_1,\ldots,y_{n_{i\negvthinspace j}}) \medrightarrow x_k \teq y_k}
  \\[-0.5\jot]
\text{Exhaustiveness:}\enskip
  & \smash{\const{d}_{i1}(x) \mathrel\lor \cdots \mathrel\lor \const{d}_{im_i}(x)}
  \\[-0.5\jot]
\text{Selection:}\enskip
  & \smash{\const{s}_{i\negvthinspace j}^{\,k}(\const{C}_{i\negvthinspace j}(x_1,\ldots,x_{n_{i\negvthinspace j}})) \teq x_k}
\end{aligned}
\]
%
%In the algebraic jargon, exhaustiveness helps ensure that ``no
%junk'' exists, whereas distinctness and injectivity guarantee that ``no
%confusion'' can arise.
%The result of selectors applied to the wrong
%constructor is left completely unspecified.
%
%
%  * how to deal with "wrong" selectors, e.g.
%        hd(nil1) = hd(nil2)?
%      * leave them unspecified; hence hd(nil1) = hd(nil2) in some models,
%        and not in other models
%
%
Datatypes are additionally characterized by an induction principle.
For the natural numbers constructed from $\const{Z}$ and $\const{S}$,
induction prohibits models that contain infinite values.
% $\const{S}(\const{S}(\ldots))$.
%
For codatatypes, the dual notion is called coinduction:
Two values that yield the same observations must be equal, 
where the observations are made through selectors and discriminators.
Codatatypes are also guaranteed to contain all values corresponding to 
infinite variable-free constructor terms.

%Given a signature $\Sig$, $\thD$ refers to the \emph{theory of
%datatypes and codatatypes},
%which %in addition to $\Sig$
%defines a class of $\Sig$-interpretations $\JJJJ$,
%namely those that satisfy the %axioms --- existence of all infinite %codatatype values cannot be axiomatized
%properties mentioned in this section, including (co)induction. The %interpretations
%in~$\JJJJ$ share the same interpretation for constructor terms and correctly
%applied selector terms (up to isomorphism) %renaming of domain elements
%but may differ on variables and wrongly applied selector terms.
%A formula is $\thD$-\emph{satisfiable} if there
%exists an interpretation in $\JJJJ$ that satisfies it.
%% otherwise, it is $\thD$-unsatisfiable. (I trust the readers' intelligence %when
%% it comes to English prefixes like non-, in-, un-, and a-.)
%%
%For deciding universal formulas, induction can be replaced by the acyclicity
%axiom schema, which states that constructor terms cannot be equal to
%any of their proper subterms \cite{barrett-et-al-2007}.
%Dually, coinduction can be replaced by the uniqueness schema, which
%asserts that codatatype values are fully characterized by their %possibly
%%infinite
%expansion \cite[Theorem 8.1, 2$\,{\Leftrightarrow}\,$5]{rutten-2000}.

% TODO: State more precisely and prove?

%    * :
%        enough to consider acyclicity -- no way to specify infinite objects
%        otherwise

%    * codatatypes:
%      * when looking at the universal theory, enough to
%        consider uniqueness -- no way to express that certain infinite
%        acyclic objects do not exist

%For datatypes, any recursive specification gives rise to an infinite %datatype.
%Paradoxically, this does not extend to codatatypes:
%Some codatatypes are so degenerate as to be finite even though they
%have infinite values. A simple example is
%\vthinspace$\keyw{codata}~\ty{a} = \const{A}(\ty{a})$, which is corecursive
%and yet has a cardinality of one;
%its unique value is $\MU a.\; \const{A}(a)$. Other specimens are
%$\ty{stream}_{\vthinspace\ty{unit}\,}$
%and both \ty{b} and \ty{c} in the specification
%\[\begin{aligned}[t]
%      \keyw{codata}\;\, \ty{b} & \,=\, \const{B}(\ty{b},\: \ty{c},\: %\ty{b},\: \ty{unit}) \\[-1\jot]
%      \keyw{and}\;\, \ty{c} & \,=\, \const{C}(\ty{a},\: \ty{b},\: \ty{c})
%\end{aligned}
%\]
%assuming \ty{unit} is a datatype with the single constructor $\const{Unity} :
%\ty{unit}$. We call such codatatypes
%\emph{corecursive singletons}, or simply singletons.
%For the decision procedure, it will be
%crucial to detect these. %, even if they rarely arise in practice.
%A type may also be a corecursive singleton only in some models. If the %example
%above is altered to make \ty{unit} an uninterpreted type, \ty{b} and \ty{c} %will be
%singletons precisely when \ty{unit} is interpreted as a singleton.
%Fortunately, given cardinalities for the ordinary types,
%it is easy to characterize this degenerate case.
%
%% In other words, all finite corecursive codatatypes are corecursive %singletons.
%
%\begin{lemma}%[Corecursive Singletons]%
%\label{lem:corecursive-singletons}%
%\afterDot
%Let $\delta$ be a corecursive codatatype. For any interpretation in $\JJJJ$,
%the domain interpreting $\delta$ is either infinite or a singleton. In the
%latter case, $\delta$ necessarily has a single constructor, whose arguments %have
%types that are interpreted as singleton domains.
%\end{lemma}

\section{The Decision Procedure} % for (Co)datatypes}
\label{sec:the-decision-procedure}

Given a fixed signature, %~$\Sig$,
the decision procedure for the universal theory of (co)data\-types %$\thD$
determines the
%$\thD$-
satisfiability of finite sets $\Ec$ of literals:\ equalities
and disequalities between first-order terms, %$\Sig$-terms,
whose variables are interpreted existentially.
The decision procedure is formulated as an %tableau-like
abstract calculus.
%Following the tradition of refutational theorem proving,
Proving a universal quantifier-free conjecture is reduced to showing that
its negation is unsatisfiable. 
%The presentation is
%inspired by Barrett {\em et al.} \shortcite{barrett-et-al-2007} but at
%a higher level, using unoriented equations instead of oriented ones.

To simplify the presentation, we make a few assumptions about
the signature. %$\Sig$.
First, all codatatypes %in $\Codata$
are corecursive. This is reasonable
because noncorecursive codatatypes can be seen as nonrecursive
datatypes.
Second, all ordinary types have infinite cardinality.
Without quantifiers, the constraints $\Ec$ cannot entail an upper
bound on the cardinality of any uninterpreted type, so it is safe to consider these types
infinite. As for ordinary types interpreted finitely by other theories (e.g.,
bit vectors), each interpreted type having finite cardinality~$n$
can be viewed as a %n enumeration
datatype with $n$~nullary constructors.
%\cite{barrett-et-al-2007}.

%AJR: would prefer splitting this section into two parts (calculus, correctness), let me know if you agree.
%JB: I fully agree, but I tuned the titles a little bit. Also, I tried
%%% to avoid such "meta" (or "road-sign") wording as
%%% "This section will describe such-and-such".

% whose derivation rules are applied until saturation or contradiction.

%We will commonly denote tuples of terms $( t_1, \ldots, t_n )$ in bold font, as $\vec t$.
%We assume that all $\Sig$-terms in $\Ec$ are \emph{normalized}, meaning that all subterms of the form $\const{s}^{\,k}_{\negvthinspace j}( \const{C}_{\negvthinspace j}(t_1,\ldots,t_n) )$
%are simplified to $t_k$. All literals added to $\Ec$ are also implicitly
%normalized in this manner.

Our calculus for the theory of (co)datatypes
consists of derivation rules.
A derivation rule can be applied to $\Ec$ if %all
the specified
premises are met.
The conclusion either specifies equalities to be added to $\Ec$
or is $\bot$ (contradiction).
% (in which case we call an application of it \emph{nonterminal})
% (in which case we call an application of it \emph{terminal}).
One of the rules has multiple conclusions, % separated by $\ror$,
denoting branching.
%
An application of a rule is \emph{redundant} if one of its non-$\bot$
conclusions leaves $\Ec$ unchanged.
A \emph{derivation tree} is a %finite
tree whose nodes are finite sets of
equalities, such that child nodes are obtained by a nonredundant application of a
derivation rule to the parent. A derivation tree is \emph{closed} if all of
its leaf nodes are $\bot$. A node is \emph{saturated} if no nonredundant
instance of a rule can be applied to it.

The derivation rules are partitioned into three phases, given in
Figures \ref{fig:cc-rules}, \ref{fig:ab-rules}, and \ref{fig:split-rule}.
The first phase computes the bidirectional closure of $\Ec$. The second
phase makes inferences based on acyclicity (for datatypes) and uniqueness
(for codatatypes).
The third phase performs case distinctions on constructors for
various terms occurring in $\Ec$.
%Following the conventions from~\cite{},
%The derivation rules are given in \relax{guarded assignment form},
%where
%
The rules belonging to a phase have priority over those of %the
subsequent
phases. The rules are applied until the derivation tree is closed or all leaf nodes
are saturated.

%We assume that all $\Sig$-terms in $\Ec$ are \emph{normalized}, meaning that all subterms of the form $\const{s}^{\,k}_{\negvthinspace j}( \const{C}_{\negvthinspace j}(t_1,\ldots,t_n) )$
%are simplified to $t_i$, and moreover assume that all %additional
%literals added to $\Ec$ are normalized in this manner.
%We present the calculus in three steps.
%In the first step, we compute the bidirectional closure of $\Ec$;
%in the second step, we make inferences based on acyclicity and uniqueness;
%and in the third step, %(when necessary),
%we branch on constructor types for various terms in $\tEc$.
%Following the conventions from~\cite{},
%the derivation rules of our calculus are given in \emph{guarded assignment form},
%where a rule can be applied to $\Ec$ if it meets all of the specified premises for $\Ec$.

\subsection{Phase 1: Computing the Bidirectional Closure}

\begin{figure}[b!]
%\small
\centering
\begin{tabular}{@{}c@{}}
\(
\inferrule{
  t \in \tEc
}{
  \Ec := \Ec,\: t \teq t
}
\)
\rn{Refl}
\quad
\(
\inferrule{
 t \teq u \in \Ec
}{
 \Ec := \Ec,\: u \teq t
}
\)
\rn{Sym}
\\[5\jot]
\(
\inferrule{
  s \teq t,\; t \teq u \in \Ec
}{
  \Ec := \Ec,\: s \teq u
}
\)
\rn{Trans}
\quad
\(
\inferrule{
  \vec t \teq \vec u \in \Ec
  \betweenantes
  \const f( \vec t \,),\, \const f( \vec u ) \in \tEc
}{
  \Ec := \Ec,\: \const f( \vec t \,) \teq \const f( \vec u )
}
\)
\rn{Cong}\\[5\jot]
\(
\inferrule{
  t \teq u,\; t \tneq u \in \Ec
}{
  \bot
}
\)
\rn{Conflict}
\quad
\(
\inferrule{
  \const{C}( \vec t \,) \teq \const{C}( \vec u ) \in \Ec
}{
  \Ec := \Ec,\: \vec t \teq \vec u
}
\)
\rn{Inject}
\\[5\jot]
\(
\inferrule{
  \const{C}( \vec t \,) \teq \const{D}( \vec u ) \in \Ec
  \betweenantes
  \const{C} \not= \const{D}
}{
  \bot
}
\)
\rn{Clash}
\end{tabular}
\vspace*{-2pt} %% TYPESETTING HACK
\caption{\,Derivation rules for bidirectional closure%.
}
\label{fig:cc-rules}
\end{figure}

In conjunction with \rn{Refl}, \rn{Sym}, and \rn{Trans}, the \rn{Cong} rule computes the congruence (upward) closure,
whereas the \rn{Inject} and \rn{Clash} rules %together
compute the unification (downward) closure.
For unification, %additional
equalities are inferred based on the injectivity of constructors by \rn{Inject},
and failures to unify equated terms are recognized by \rn{Clash}.
\rn{Conflict} recognizes when an equality and its negation both occur in $\Ec$, in which case $\Ec$ has no model.

Let $\tEc$ denote the set of %$\Sig$-
terms occurring in $\Ec$.
At the end of the first phase, $\Ec$ induces an equivalence
relation over $\tEc$ such that two terms $t$ and $u$ are equivalent if and
only if $t \teq u \in \Ec$.
Thus, we can regard $\Ec$ as a set of
equivalence classes of terms. For a term $t \in \tEc$, we write $\ec{t}$ to
denote the equivalence class of $t$ in $\Ec$.
Moreover, at the end of this phase, each equivalence class $\ec{t}$ contains
at most %%% JB: dropped ()'s
one constructor term that is unique up to congruence.
Thus, in the subsequent phases, 
when considering the case that $\ec{t}$ contains constructor terms,
it is enough %for our purposes
to select an arbitrary constructor term from $\ec{t}$ among these.

\subsection{Phase 2: Applying Acyclicity and Uniqueness}

%For presentation of the rules in this phase, we rely on a representation of terms in the $\mu$-notation.
%The premises of the rules that make up the second phase refer to
The rules in this phase are described in terms of a mapping $\Val$
that assigns to each equivalence class a $\mu$-term. % as its representative.
%\rem{Not explicitly constructed, add here?}

\begin{figure}[b!]
%\vspace*{+6pt} %% TYPESETTING HACK
%\small
\centering
\begin{tabular}{@{}c@{}}
\(
\inferrule{
  t : \delta \in \Data
  \betweenantes
  \Val \smash{\ec{t}} = \MU x.\; u
  \betweenantes
  x \in \FV( u )
}{
  \bot
}
\)
\rn{Acyclic}
\\[5\jot]
\(
\inferrule{
 t, u : \delta \in \Codata
 \betweenantes
 \Val \smash{\ec{t}} \aequiv \Val \smash{\ec{u}}
}{
 \Ec := \Ec,\: t \teq u
}
\)
\rn{Unique}
\end{tabular}
\vspace*{-2pt} %% TYPESETTING HACK
\caption{\,Derivation rules for acyclicity and uniqueness%.
}
\label{fig:ab-rules}
\end{figure}

Formally, $\mu$-\emph{terms} are defined recursively as being either a variable $x$
or an applied constructor
$\MU x.\: \const{C}( \vec t\, )$ for some $\const{C} \in \Ctr$ and
$\mu$-terms $\vec t$ of the expected types.
The variable~$x$ need not occur free in the $\mu$-binder's body, in which case
the binder can be omitted.
$\FV( t )$ denotes the set of free variables occurring in the $\mu$-term~$t$.
A $\mu$-term is \emph{closed} if %and only if --- by convention, "and only if" is not necessary for *definitions* (but add it back if you disagree)
it contains no free variables. It is \emph{cyclic} if %and only if --- ditto
it contains a bound variable. The $\alpha$\emph{-equiv\-alence} relation $t \aequiv u$
indicates that the $\mu$-terms $t$ and $u$
are syntactically equivalent for some capture-avoiding renaming of $\mu$-bound variables---e.g.,
%$\MU x.\; \const{C}( x ) \aequiv \MU y.\; \const{C}( y )$ and
$\MU x.\; \const{D}( y, x ) \aequiv \MU z.\; \const{D}( y, z )$,
but
$\MU x.\; \const{C}( x ) \not\aequiv \MU x.\; \const{D}( y, x ) \not\aequiv \MU x.\; \const{D}( z, x )
\not\aequiv \MU y.\; \const{D}( y, x )$.
Two $\mu$-terms can denote the same value despite being $\alpha$-disequivalent---e.g.,
$\MU x.\; \const{S}( x ) \not\aequiv \MU y.\; \const{S}( \const{S}( y ) )$.
%In the \rn{Acyclic} rule,

%Recall that $\mu$-bindings can be used for representing possibly cyclic terms and values.
%(Section~\ref{sec:introduction}).
% for example, $\MU x.\; \const{C}( \const{0}, x )$ represents the cyclic value $\const{C}( \const{0}, \const{C}( \const{0}, \ldots ))$.
%either in the case when $\tau$ is a codatatype or datatype type,
%$\tau \notin \Codata$.

%%% But there are no constants of type $\tau \in \Nondata$ -- at most variables!
%
%For uniformity, we also consider $%\MU x.\;
%\const{c}$ to be a $\mu$-term if $\const{c}$ is a constant of type $\tau \in \Nondata$.
%
%%% I think this should be clear enough from the "Conventions" paragraph at the
%%% end of the introduction.
%%
% which we define recursively:
%if $\const{C} : \vec \tau \rightarrow \upsilon$
%and $\vec v$ are well-typed $\mu$-terms of type $\vec \tau$ under the assumption that $x$ has type $\upsilon$,
%then $\MU x.\; \const{C}( \vec v )$ is a well-typed term of type $\upsilon$.
%
%, or informally are \emph{observationally equivalent}.
%For convenience, we use $\mu$-terms to refer to (classes of) values for both codatatype and datatype terms,
%where in the latter case, a $\mu$-term with a bound variable denotes an infeasible term.
%where the latter case adds the restriction on $\mu$-terms $t$ that no subterms of $t$ contain are bound variables.

The mapping $\Val$ is constructed as follows.
%
With each equivalence class $\ec{u}$, we associate a fresh variable $\Varec{u}$
of the same type as $u$. %not occurring in $\tEc$,
For a term $t \in \tEc$, 
we write $\Varec{t}$ to denote the variable associated with
the equivalence class $\ec{t}$.
Initially, we set $\Val\ec{u} := {\Varec{u}}$ for each equivalence class $\ec{u}$. Because $\Varec{u}$ is
unconstrained,
this indicates that there are initially no
constraints on the values for any equivalence class $\ec{u}$. 
The mapping $\Val$
is refined by applying the following unfolding rule exhaustively:\strut
\[
\hbox{\(
\inferrule{
  {\Varec{u}} \in \FV( \Val )
  \betweenantes
  \const{C}( t_1, \ldots, t_n ) \in \ec{u}
  \betweenantes
  \const{C} \in \Ctr
}{
  \Val := \Val [{\Varec{u}} \mapsto \MU {\Varec{u}}.\; \const{C}( {\Varec{t_1}}, \ldots, {\Varec{t_n}} )]
}
\)
%\rn{Unfold}
}
\]
$\FV( \Val )$ denotes the set of free variables occurring in $\Val$'s range,
and $\Val[x \mapsto t]$ denotes the variable-\emph{capturing} substitution of $t$ for
$x$ in $\Val$'s range. It is easy to see that the height of terms produced as a
result of the unfolding is bounded by the number of equivalence classes of
$\Ec$, and thus the construction of $\Val$ will terminate.

%AJR: moved this paragraph after the construction to avoid mistaking this paragraph as part of the formal definition.
The $\mu$-term $\Val[t]$ describes a class of values
that $t$ and other members of $t$'s equivalence class can take in models of $\Ec$.
When $\tau$ is a datatype, % \in \Data$,
a cyclic $\mu$-term describes an infeasible class of values.

\begin{examplex}
Suppose that $\Ec$ contains four distinct equivalence classes $\ec{w}$, $\ec{x}$, $\ec{\yasx}$, and~$\ec{z}$
such that $\const{C}(w,y) \in \ec{x}$ and $\const{C}(z,x) \in \ec{\yasx}$ for some $\const{C} \in \Ctr$.
A possible sequence of unfolding steps is given below, omitting
trivial entries such as $\ec{w} \mapsto {\Varec{w}}$.
%
\begin{enumerate}
\item Unfold $\Varec{x}$:\enskip $\Val = \{\vthinspace  \ec{x} \mapsto \MU {\Varec{x}}.\; \const{C}( {\Varec{w}},\, {\Varec{\yasx}} ) \vthinspace\}$
\item Unfold $\Varec{\yasx}$:\enskip $\Val = \{\vthinspace  \!\begin{aligned}[t]
  & \ec{x} \mapsto \MU {\Varec{x}}.\; \const{C}( {\Varec{w}},\; \MU {\Varec{\yasx}}.\; \const{C}( {\Varec{z}},\, {\Varec{x}} ) ),\; \\[-.5\jot]
  & \ec{\yasx} \mapsto \MU {\Varec{\yasx}}.\; \const{C}( {\Varec{z}},\, {\Varec{x}} ) \vthinspace\}\end{aligned}$
\item Unfold $\Varec{x}$:\enskip $\Val = \{\vthinspace \!\begin{aligned}[t]
  & \ec{x} \mapsto \MU {\Varec{x}}.\; \const{C}( {\Varec{w}},\; \MU {\Varec{\yasx}}.\; \const{C}( {\Varec{z}},\, {\Varec{x}} ) ),\; \\[-.5\jot]
  & \ec{\yasx} \mapsto \MU {\Varec{\yasx}}.\; \const{C}( {\Varec{z}},\; \MU {\Varec{x}}.\; \const{C}( {\Varec{w}},\, {\Varec{\yasx}} ) ) \vthinspace\}\end{aligned}$
\end{enumerate}
%
The resulting $\Val$ indicates that the values for $x$ and $y$ in models of $\Ec$
must be of the forms $\const{C}( {\Varec{w}}, \const{C}( {\Varec{z}},\allowbreak \const{C}( {\Varec{w}},\allowbreak \const{C}( {\Varec{z}},\ldots ))))$
and $\const{C}( {\Varec{z}}, \const{C}( {\Varec{w}}, \const{C}( {\Varec{z}}, \const{C}( {\Varec{w}}, \ldots ))))$,
respectively. %, for some values of ${\Varec{w}}$ and ${\Varec{z}}$.
\xend
\end{examplex}

Given the mapping $\Val$, the \rn{Acyclic} and \rn{Unique} rules work as follows.
For acyclicity, if $\ec{t}$ is a datatype equivalence class
whose values $\Val \ec{t} = \MU x.\; u$ are cyclic
(expressed by $x \in \FV( u )$),
then $\Ec$ is %$\thD$-
unsatisfiable.
For uniqueness, if $\ec{t}$, $\ec{u}$ are two codatatype equivalence classes
whose values $\Val \ec{t}$, $\Val \ec{u}$ are $\alpha$-equivalent,
%for a capture-avoiding renaming of $\mu$-bound variables,
then $t$ is equal to $u$. Comparison for $\alpha$-equivalence may seem too restrictive, since
$\MU x.\; \const{S}(x)$ and $\MU y.\; \const{S}(\const{S}(y))$ specify the same
value despite being $\alpha$-disequivalent, but the rule will
make progress by discovering that the subterm $\const{S}(y)$ of $\MU y.\;
\const{S}(\const{S}(y))$ must be equal to the entire term,
as demonstrated next.

%% Minor terminology point:
%% A function symbol can have a "type signature" (but we're trying to avoid that terminology);
%% unless it's a constant, it doesn't have a (first-order) type. So I'm rephrasing.

\begin{examplex}
Let $\Ec = \{ x \teq \const{S}(x),\; y \teq \const{S}(\const{S}(y)) \}$.
After phase~1, the equivalence classes %of $\Ec$
are
$\{ x,\, \const{S}(x) \}$,
$\{ y,\, \const{S}(\const{S}(y)) \}$,
and $\{ \const{S}(y) \}$.
Constructing $\Val$ yields
\begin{align*}
\Val \ec{x} & \,=\, \MU {\Varec{x}}.\; \const{S}(\Varec{x}) 
\kern2.0em %% TYPESETTING
\Val \ec{\yasx}  \,=\,
\MU {\Varec{\yasx}}.\; \const{S}(\smash{\MU {\VAREC{\const{S}(y)}}}.\; \const{S}( {\Varec{\yasx}} ) )
%\kern0.25em %% TYPESETTING
% &
\\[-.5\jot]
\Val \ec{\const{S}(y)} & \,=\, 
\MU {\VAREC{\const{S}(y)}}.\; \const{S}(\MU {\Varec{\yasx}}.\; \const{S}( {\VAREC{\const{S}(y)}} ) )
\end{align*}
Since $\Val \ec{\yasx} \aequiv \Val \ec{\const{S}(y)}$,
%for the renaming
%$\{ {\Varec{\yasx}} \mapsto {\VAREC{\const{S}(y)}}, {\VAREC{\const{S}(y)}} \mapsto {\Varec{\yasx}} \}$,
the \rn{Unique} rule applies to derive $y \teq \const{S}(y)$.
%Intuitively, this equality holds, since the values of $y$ and $\const{S}(y)$
%are equivalent.
%
At this point, phase~1 is activated again, % to XXX the equivalence classes,
yielding the equivalence classes
$\{ x,\, \const{S}(x) \}$ and
$\{ y,\, \const{S}(y),\allowbreak\, \const{S}(\const{S}(y)) \}$.
The mapping $\Val$ is updated accordingly:
\begin{align*}
\Val \ec{x} & \,=\, \MU {\Varec{x}}.\; \const{S}(\Varec{x})
&
\Val \ec{\yasx} & \,=\, \MU {\Varec{\yasx}}.\; \const{S}({\Varec{\yasx}})
\end{align*}
Since $\Val \ec{x} \aequiv \Val \ec{\yasx}$,
%for the renaming
%$\{ {\Varec{\yasx}} \mapsto {\VAREC{\const{S}(y)}}, {\VAREC{\const{S}(y)}} \mapsto {\Varec{\yasx}} \}$,
\rn{Unique} can finally derive $x \teq y$.
\xend
\end{examplex}

\subsection{Phase 3: Branching}

\begin{figure}[b!]
%\vspace*{+6pt} %% TYPESETTING HACK
%\small
\centering
\begin{tabular}{@{}c@{}}
\(
\inferrule{
  t : \delta
  \betweenantes
  t \in \tEc
  \betweenantes
  \Ctr^\delta = \{ \const{C}_1, \ldots, \const{C}_m \}
\\
  \bigl( \const s( t ) \in \tEc \text{ and } \const s \in \Sel^\delta \bigr)
  \text{ or }
  \bigl( \delta \in \Data \text{ and } %\left|
  \delta
  %\right|
  \text{ is finite} \bigr)
}{
  {\mathop{\big|\kern-.25ex\big|}\vthinspace}_{i=1}^n\, \Ec := \Ec,\: \DISC{i} %\ROR
 % \ROR \cdots \ROR \Ec := \Ec,\: \DISC{m}
}
\)
\rn{Split}
\\[5\jot]
\(
\inferrule{
  t, u : \delta \in \Codata
  \betweenantes
  t, u \in \tEc
  \betweenantes
  \delta \text{ is a singleton}
}{
  \Ec := \Ec,\: t \teq u
}
\)
\rn{Single}
\end{tabular}
\vspace*{-2pt} %% TYPESETTING HACK
\caption{\,Derivation rules for branching%.
%All pairs of terms whose type has cardinality 1 are entailed to be equal (the degenerate case).
%Constructors must be assigned for all terms $t$ if has a selector is applied to it, or if $t$ has finite datatype type.
}
\label{fig:split-rule}
\end{figure}

If a selector is applied to a term $t$, or if $t$'s type is a finite datatype,
$t$'s equivalence class must contain a
$\delta$ constructor term.
This is enforced in the third phase by the \rn{Split} rule.
Another rule, \rn{Single}, focuses on the degenerate case where two
terms %from $\tEc$
are of a \emph{singleton} type (one for which there exists only one value),
and are therefore equal.
Notice that corecursive singleton types may have infinite values. A simple example is
\vthinspace$\keyw{codata}~\ty{a} = \const{A}(\ty{a})$, which is corecursive
and yet has a cardinality of one;
its unique value is $\MU a.\; \const{A}(a)$.
Both
\rn{Split}'s finiteness assumption %on the datatype
and \rn{Single}'s singleton
constraint %on the codatatype
can be evaluated statically
based on a recursive computation of the cardinalities of the
constructors' argument types.
%This step relies on the assumption that uninterpreted types are infinite.

\subsection{Termination and Correctness}

%We now show (FIXME) the termination and correctness of the calculus.
%Correctness means the following:
%If there exists a closed derivation tree with root node
%$\Ec$, then $\Ec$ is %$\thD$-
%unsatisfiable; and if there exists
%a derivation tree with root node $\Ec$ that contains a saturated node, then
%$\Ec$ is %$\thD$-
%satisfiable.
We state the following properties of derivation trees generated by the calculus.

\begin{theoremi}
\label{thm:t}%
\afterDot
All derivation trees are finite.
\end{theoremi}

\begin{theoremii}
\label{thm:rs}%
\afterDot
If there exists a closed derivation tree with root node\/ $\Ec$, then\/ $\Ec$ is %$\thD$-
unsatisfiable.
\end{theoremii}

\begin{theoremiii}
\label{thm:ss}%
\afterDot
If there exists a derivation tree with root node $\Ec$ containing a saturated node, then $\Ec$ is %$\thD$-
satisfiable.
\end{theoremiii}

\looseness=-1
By Theorems~1, 2, and 3, the
calculus is sound and complete for the universal theory of (co)datatypes. We may
rightly call it a decision procedure for that theory.
The proof of solution soundness is constructive in that it provides a
method for constructing a model for a saturated configuration.

%AJR : if necessary...
%To give an intuition how this model is constructed,
%we consider the mapping $\Val$ from Step 2 of the procedure,
%and apply additional substitutions over the free variables in its range
%to obtain a mapping, call it $\ValC$, 
%from equivalence classes to closed $\MU$-terms.
%Then, for each equivalence class $\ec{t}$ in the domain of $\ValC$,
%we interpret each variable in $\ec{t}$ as $\ValC \ec{t}$.
%The properties of a saturated configuration ensure
%that $\ValC$ can be constructed such that all constraints in our input are satisfied.

\section{Evaluation} % on Isabelle Problems}
\label{sec:evaluation}

\newcommand\gandl{SBT}
\newcommand\HD[1]{\hbox to2em{\relax\hfill\!\!\!\!#1\!\!\!\!\hfill}}

The decision procedure for (co)datatypes is useful both for proving (via
negation, in the refutational style) and for model finding
\cite{ge-de-moura-2009,reynolds-et-al-2013}.
It is in fact vital for finite model finding,
because the acyclicity and uniqueness rules are necessary for solution
soundness, without which the generated models would often be
spurious. For example, given the constraints
\begin{align*}
\const{zeros} & \teq \const{SCons}(0,\:\const{zeros})
& \const{repeat}(n) & \teq \const{SCons}(n,\:\const{repeat}(n))
\end{align*}
the conjecture
$\const{zeros} = \const{repeat}(0)$
would be ``refuted'' by a spurious countermodel that interprets
\const{zero} and $\const{repeat}(0)$ by two distinct
values $\MU s.\; \const{SCons}(0, s)$,
violating uniqueness.

By contrast, the contributions of the decision procedure
to proving are less obvious; they depend on how
often acyclicity and uniqueness are necessary for a proof.
To evaluate this,
we generated benchmark problems from existing interactive
proof goals arising in existing
Isabelle formalizations, using Sledgehammer \cite{blanchette-et-al-2013-smt}
as translator.
%There are not yet many benchmarks available, since codatatypes are a
%recent addition to Isabelle \cite{blanchette-et-al-2014-impl}. \rem{Necessary to mention this? Seems to detract from significance of contribution.}
We
included all the formalizations from the Isabelle distribution (Distro, 1179~goals)
and the \emph{Archive of Formal Proofs} (AFP, 3014~goals) that define codatatypes falling within the supported fragment. We
also included formalizations about Bird and Stern--Brocot trees (\gandl,
265~goals). % \cite{gammie-lochbihler-2016}.
To exercise the datatype support, formalizations about finite
lists and trees
were added to the first two benchmark sets.
%The formalizations were selected before
%conducting any experiments.
%The experimental data are available
%online.%
%\footnote{\url{http://lara.epfl.ch/~reynolds/JAR-CADE2015-cdt/}}

%http://www21.in.tum.de/~blanchet/codp_data.tgz}}

%  & 879 & 2974\phantom{0} & 317 & 4170

For each proof goal in each formalization, we used Sledgehammer to select either 16 or
256~lemmas, which were monomorphized and translated to SMT-LIB along with the
goal. The resulting problem was given to the
development version of CVC4
(from 15 September 2015) and to
Z3 4.3.2 for comparison, each running for
up to 60~s. % on StarExec \cite{stump-et-al-2014-starexec}.
Problems not involving any (co)datatypes were left out.

CVC4 was run on each problem several times, with the
support for datatypes and codatatypes either enabled or disabled. The
contributions of the acyclicity and uniqueness rules were also measured,
by selectively enabling or disabling the rules.
% to find
% out whether these somewhat expensive rules are useful in practice.
Even when the
decision procedure is disabled, the problems may contain
basic lemmas about constructors and selectors, allowing some (co)datatype
reasoning. This is especially true for problems generated using 256~lemmas.
The problems with 16~lemmas put more stress on the decision procedure but are
less typical of Sledgehammer problems.

% when this makes sense.
%This allows us to answer the question, \relax{What are the
%benefits of activating the decision procedure as opposed to letting
%Sledgehammer do what it would normally do?}

%  * experience with such features is not extremely high -- e.g. arithmetic,
%    a most useful theory on lots of benchmarks, increases Sledgehammer's
%    success rate by 2 percentage points, or 4\%, with Z3 in earlier work \cite{xxx}

%  * so when analyzing statistics of this kind, with highly varied problems,
%    we must not overestimate the importance of a single trick
%  * on the other hand: every percentage point counts! cite Tom Hales

\newcommand\nummodden{num\hbox{\rm\_}mod\hbox{\rm\_}den}

\newcommand\captioni{\,Number of solved goals with $n$~lemmas per goal}

%%% TYPESETTING: hack
\setcounter{table}{3}

\begin{table}[h!]
\normalsize
\begin{center}\begin{tabular}{@{\;}l@{\kern1.5em}c@{\kern.5em}c@{\kern1em}c@{\kern.5em}c@{\;}}
  & \multicolumn{2}{@{}c@{\kern1em}}{$n = 16$\,} & \multicolumn{2}{@{}c@{\;}}{$n = 256$\;} \\%[-0.5pt]
  & \HD{CVC4} & \HD{Z3} & \HD{CVC4} & \HD{\,Z3}
\MIDRULE
No (co)datatypes
 &  1099  &  1097  &  2209  &  1911 \\%[\jot]
Datatypes without \rn{Acyclic}
 &  1116  &  -- &  2211  &  -- \\
Full datatypes
 &  1120  &  1121  &  2211  &  1901 \\%[\jot]
Codatatypes without \rn{Unique}\!\!
 &  1132  &  --  &  2208  &  -- \\
Full codatatypes
 &  1137  &  -- &  \bfseries 2220  &  -- \\%[\jot]
Full (co)datatypes
 &  \bfseries 1157  &  -- &  2219  &  -- %\\[\jot]
\end{tabular}\end{center}
\caption{\captioni}
\label{tab:bench}
\end{table}

The results are summarized in Table \ref{tab:bench}.
For the 16-lemma problems, it accounts for an overall
success rate increase of over 5\%.
Moreover, every aspect of the procedure, including the
more expensive rules, makes a contribution.
%
For the 256-lemma problems, the difference
is much smaller, at 0.5\%.
%For Isabelle
%users, the practical usefulness of interpreted (co)datatypes is roughly
%comparable to that of arithmetic \cite{blanchette-et-al-2013-smt}, although this
%obviously depends on the application.
Table~\ref{tab:bench} indicates that
the theoretically stronger instances of the decision
procedure do not always subsume the weaker ones in practice.
The raw data reveal that the full procedure proved 27~goals that
could not be proved without it, but failed for 17~goals that could be proved
without it.
%This potentially points to poor interactions between the decision
%procedure and the quantifier instantiation module
%\cite{ReynoldsTinelliMoura14}.

\section{Conclusion}
\label{sec:conclusion}

We presented a decision procedure for the universal theory of datatypes and
codatatypes. Our approach relies on $\mu$-terms to represent cyclic values.
Although this aspect is primarily motivated by codatatypes, it makes
a uniform account of datatypes and codatatypes possible---in particular,
the acyclicity rule for datatypes exploits $\mu$-terms to detect cycles.
% are not very
% difficult per se, but there are tricky corner cases to take care of if we care
% about completeness (which we do).
%% alliteration
The empirical results on Isabelle benchmarks
confirm that CVC4's new capabilities improve the state of the art.

This work is part of a wider program that aims at enriching automatic provers
with high-level features and at reducing the gap between automatic and
interactive theorem proving.
We are currently interfacing CVC4's finite model finding capabilities
for generating counterexamples in proof assistants
\cite{reynolds-et-al-2015-smt}.
%as an alternative to Nitpick;
The acyclicity and uniqueness rules are
crucial to exclude spurious counterexamples.
%As future work, it would be useful to implement
%proof reconstruction for (co)data\-type inferences in Isabelle.
%In addition, it might be worthwhile to
%extend SMT solvers with dedicated support for (co)recursion.

\section*{Acknowledgment}

We owe a great debt to the development team of CVC4, including Clark Barrett
and Cesare Tinelli, and in particular Morgan Deters, who jointly with the
first author developed the initial version of the decision procedure for
datatypes in CVC4.
We also want to thank everyone who helped us with the longer versions of
this paper.
The second author's work was partially supported by
the Deutsche
Forschungs\-gemein\-schaft %(DFG)
project ``Den Hammer h\"arten'' (grant NI\,491\slash 14-1)
and the Inria technological development
action ``Contre-exemples utilisables par Isabelle et Coq'' (CUIC).

\raggedright

\bibliographystyle{named}
\bibliography{bib}{}

%%% TYPESETTING: hacks

\vfill

~

\end{document}
