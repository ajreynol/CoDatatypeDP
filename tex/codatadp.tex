\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{arydshln}
\usepackage[scaled=.82]{beramono}
\usepackage{booktabs}
\usepackage{bussproofs}
\usepackage{calc}
\usepackage{cite}
\usepackage{mathptmx}
%\usepackage{txfonts}
%\usepackage{mathrsfs}
%\usepackage{pifont}
%\usepackage{smallcap}
\usepackage{mathpartir} 
\usepackage{stmaryrd}
\usepackage{subfigure}
\usepackage[usenames]{color}
%\usepackage{graphicx}
%\usepackage{newcent}
\usepackage{textcomp}
%\usepackage{tipa}
\usepackage{units}
\usepackage{url}
\usepackage[all]{xy}

\excludeversion{report}
\includeversion{paper}

\def\thewordpaper{paper}
\newcommand\dotReportFootnote[1]{.}

\begin{report}
\def\thewordpaper{report}
\newcommand\dotReportFootnote[1]{.\footnote{#1}}
\end{report}

\newcommand\afterLdots{\kern.1em} %% TYPESETTING

% for "bussproofs" package
\EnableBpAbbreviations
\def\ScoreOverhang{1.5pt}
\def\proofSkipAmount{\vskip 0pt}
\def\defaultHypSeparation{\hskip0.75em}

\DeclareFontFamily{OT1}{pzc}{}
\DeclareFontShape{OT1}{pzc}{m}{it}{<-> s * [1.10] pzcmi7t}{}
\DeclareMathAlphabet{\mathscr}{OT1}{pzc}{m}{it}

\DeclareMathAlphabet{\mathcal}{OT1}{pzc}{m}{it}

\let\labelitemi=\labelitemii %% CHEAT!

\newcommand\cpp{C\nobreak\raisebox{.05ex}{+}\nobreak\raisebox{.05ex}{+}}

\newcommand\iPrime{i\vthinspace'\negvthinspace}
\newcommand\jPrime{j\vthinspace'\negvthinspace}

\newcommand\Sig{\mathrm{\Sigma}}

\newcommand\keyw[1]{\textbf{#1}}
\newcommand\const[1]{\textsf{#1}}
\newcommand\ty[1]{\textit{#1}}

%\renewcommand{\vec}[1]{\mathbf{#1}}
\renewcommand{\vec}[1]{\bar #1}
\newcommand{\Ec}{\mathsf{E}}
\newcommand{\Fc}{\mathsf{F}}
\newcommand{\Gc}{\mathsf{G}}
\newcommand{\Ac}{\mathsf{A}}
\newcommand{\Dc}{\mathsf{D}}
\newcommand{\Rc}{\mathsf{R}}
\newcommand{\vrange}{\mathsf{range}}
\newcommand{\vdom}{\mathsf{dom}}
\newcommand{\tEc}{\mathcal{T}(\Ec)}
\newcommand{\tcEc}{\mathcal{T}^\ast(\Ec)}
\newcommand{\rn}[1]{\textsf{\small #1}}
\newcommand{\cvc}{\textsc{cvc}{\small 4}\xspace}
\newcommand{\teq}{\approx}
\newcommand{\tneq}{\not\teq}
\newcommand{\rem}[1]{\textcolor{red}{[#1]}}
%\newcommand{\is}[1]{is\text{-} #1}
\newcommand{\is}[1]{\const{is#1}}
\newcommand{\ror}{\quad \parallel \quad}
\newcommand{\tpath}[2]{\mathcal{P}_{ #2 \rightarrow \_ }( #1 )}
\newcommand{\ttpath}[3]{\mathcal{P}_{ #2 \rightarrow #3 }( #1 )}
\newcommand{\interp}[1]{[\![ #1 ]\!]}
\newcommand{\dpath}[3]{\delta^{#1}_{#2}( #3 )}
\newcommand{\ec}[1]{ [ #1 ] }
\newcommand{\M}{\mathcal{M}}
\newcommand{\Val}{\mathcal{A}}
\newcommand{\nf}[1]{{#1}\!\!\downarrow}
\newcommand{\vsim}{\sim}

% change?
\newcommand{\thO}{T_{o}}
\newcommand{\thD}{T_{d}}

%\newcommand\Types{\mathcal{T}}
\newcommand\Types{\mathcal{Y}}
\newcommand\Funcs{\mathcal{F}}

\newcommand\Data{\Types_{\mathrm{dt}}}
\newcommand\Codata{\Types_{\mathrm{cdt}}}
\newcommand\Nondata{\Types_{\mathrm{ord}}}

\newcommand\Ctr{\Funcs_{\mathrm{ctr}}}
\newcommand\Sel{\Funcs_{\mathrm{sel}}}
%\newcommand\Plainfuncs{\Funcs_{\mathrm{other}}}

\newcommand\vthinspace{\kern+0.083333em}
\newcommand\negvthinspace{\kern-0.083333em}

%%% For final version as well?
\usepackage[
   a4paper,
   pdftex,
   pdftitle={A Decision Procedure for (Co)datatypes in SMT Solvers},
   pdfauthor={Andrew Reynolds and Jasmin Christian Blanchette},
   pdfkeywords={},
   pdfborder={0 0 0},
   draft=false,
   bookmarksnumbered,
   bookmarks,
   bookmarksdepth=2,
   bookmarksopenlevel=2,
   bookmarksopen]{hyperref}

\urlstyle{ttstyle}

\global\def\figurename{Figure}

\DeclareSymbolFont{letters}{OML}{txmi}{m}{it}

%%% REMOVE BEFORE SUBMITTING ABSOLUTELY FINAL VERSION
\makeatletter
\ps@myheadings
\makeatother

\include{defs}

\hyphenation{data-type data-types co-data-type co-data-types}


\begin{document}

\title{A Decision Procedure for (Co)datatypes in SMT Solvers}

\author {Andrew Reynolds\inst{1} \and Jasmin Christian Blanchette\inst{2,3}}
\authorrunning {A. Reynolds \and J. C. Blanchette}
\institute{
\'Ecole Polytechnique F\'ed\'erale de Lausanne (EPFL), Switzerland
\and
Inria Nancy \& LORIA, Villers-l\`es-Nancy, France
\and
Max-Planck-Institut f\"ur Informatik, Saarbr\"ucken, Germany
}

\maketitle

\begin{abstract}
Codatatypes naturally capture potentially infinite data structures and
processes. We present a decision procedure that combines reasoning about
datatypes and codatatypes. The dual of the cyclicity rule for datatypes is a
bisimilarity rule that identifies equal values, also in the presence of cycles.
The procedure is complete for universal problems and is compatible with the
Nelson--Oppen method. It has been implemented in the latest version of CVC4, a
state-of-the-art SMT solver. An evaluation based on problems generated from
Isabelle theories demonstrates the potential of the procedure.
\end{abstract}

%% The institutions above shouldn't count as footnotes
\setcounter{footnote}{0}

\section{Introduction}
\label{sec:introduction}

Freely generated datatypes are ubiquitous in functional programs and
logical specifications. They are especially
useful to represent finite data structures in computer science applications but
also arise in mathematical formalizations.
They can be implemented efficiently and enjoy
properties that can be exploited in automated reasoners. 
%
%However, because datatype values correspond to finite ground terms, they
%are generally not adequate to represent infinite objects.
%For example, the datatype of natural numbers
%constructed by $\const{Z} : \ty{nat}$ and $\const{S} : \ty{nat} \to \ty{nat}$
%only allow values of the form $\const{S}(\ldots(\const{S}(\const{Z}))\ldots)$.

To represent infinite values, % such as $\const{S}(\const{S}(\const{S}(\ldots))$,
a natural choice is to turn to codatatypes (or coinductive datatypes), the
non-well-founded dual of (inductive) datatypes.
%
Although they are sometimes perceived as esoteric, codatatypes have an important
role to play in computer science. For example, the verified C compiler CompCert
\cite{leroy-2009}, the verified Java compiler Jinja\-Threads
\cite{lochbihler-2010-jinja}, and the formalized Java memory model
\cite{lochbihler-2014-jmm} all depend on codatatypes to capture infinite
processes.
% as do the CoALP dialect of Prolog and the Dafny specification language.

Codatatypes are freely generated by their constructors, but in contrast with datatypes,
infinit\-e constructor terms are also legitimate values for codatatypes
(Section~\ref{sec:theory-of-co-datatypes}). Intuitively, the
values of a codatatype consist of all well-typed finite and infinite ground constructor
terms, and only those. For example, the specification
%
\[\keyw{codatatype}~\,\ty{enat} \,=\, \const{Z} \,\mid\, \const{S}(\ty{enat})\]
%
(using an ML-like syntax) introduces a type that
models the natural numbers $\const{Z}$, $\const{S}(\const{Z})$, $\const{S}(\const{S}(\const{Z}))$, $\ldots$\afterLdots{},
using Peano notation but extended with an
infinity value $\infty = \const{S}(\const{S}(\const{S}(\ldots)))$. Compared
with the more conventional, inductive definition
\[\keyw{datatype}~\,\ty{enat} \,=\, \const{Z} \,\mid\, \const{S}(\ty{enat}) \,\mid\, \const{Inf}\]
%
the codatatype eliminates one case by unifying the finite and infinite cases.
Moreover, equations such as $\const{S}(\infty) \teq \infty$ hold without additional
work, because both sides expand to the infinite term
$\const{S}(\const{S}(\const{S}(\ldots)))$, which uniquely identifies the
codatatype value $\infty$.

Datatypes and codatatypes are an integral part of most popular proof assistants,
including Agda, Coq, Isabelle, Matita, and PVS. In recent years, some
automatic theorem provers have been extended with dedicated reasoning facilities
for datatypes. The SMT-LIB~2 \cite{barrett-et-al-2010} syntax, implemented by
most SMT (satisfiability modulo theories) solvers, includes a theory of
datatypes.

In this \thewordpaper, we introduce a unified decision procedure for ground
problems involving both datatypes and codatatypes, and discuss extensions 
of the procedure when handling universal (non-ground) problems.
The procedure is
described abstractly as a calculus (Section~\ref{sec:the-calculus}) and is
designed to be composable via the Nelson--Oppen method \cite{nelson-oppen-1979}.
For the datatype case, it follows the lines of Barrett et al.\ \cite{barrett-et-al-2007}.
To our knowledge, our procedure is the first of its kind for the theory of
codatatypes. 

Datatypes and codatatypes share many of the same properties, so it makes sense
to consider them together. There are, however, at least three important
differences.

First, \emph{codatatypes need not be well-founded.}
For example, the type
%
\[\keyw{codatatype}~\;\ty{stream}_{\,\tau} \,=\, \const{SCons}(\tau,\, \ty{stream}_{\,\tau})\]
%
of infinite sequences, or streams, over an element type $\tau$ is allowed; the
corresponding datatype would be rejected as non-well-founded.

Second, \emph{a bisimilarity rule takes the place of the cyclicity rule of datatypes.}
Cyclic constraints such as
$\const{x} \teq \const{S}(\const{x})$ %, where $\const{C}$ is a constructor,
are unsatisfiable for datatypes but satisfiable for codatatypes.
The bisimilarity principle states that two values having the same (possibly
infinite) expansion must be equal; from $\const{x} \teq \const{S}(\const{y})$ and
$\const{y} \teq \const{S}(\const{x})$, it deduces $\const{x} \teq \const{y}$.

Third, \emph{it must be possible to express cyclic }(\emph{$\omega$-regular}) \emph{values as closed terms and
to enumerate them.} This is necessary both for finite model finding (modulo theories)
and for theory combinations. The $\mu$-binder notation is used to represent cyclic
values internally. For example,
the term $\const{SCons}(1,\, \mu s.\; \const{SCons}(0,\, \const{SCons}(9,\, s)))$
denotes the lasso-shaped sequence $1, 0, 9, 0, 9, 0, 9, \ldots$\afterLdots.

%%% 1090909 is a prime number

The cyclicity and bisimilarity rules are
needed to ensure completeness on ground problems and the absence of spurious
models in the context of finite model finding.
They cannot be replaced by finite
axiomatizations, so they naturally belong in a decision procedure. 
%    * in particular, acyclicity and bisimilarity are necessary for some proofs
%%      (and cannot be axiomatized finitely)
%    * and for model finding, without them we quickly get spurious models
%    * explain how finite model finding works
For the other (co)datatype properties---the injectivity, distinctness, and
exhaustiveness of constructors and the selector laws---it is
widely recognized that decision procedures can be more efficient than
axiomatizations.
%axiom.

\begin{paper}
The proofs of soundness and completeness are included in the technical report
associated with this paper \cite{our-report}.
\end{paper}%
The procedure is implemented in the SMT solver CVC4 as a combination
of rewriting and a theory solver
(Section~\ref{sec:the-theory-solver}).
It consists of about 2000 lines of \cpp{} code, among which 1600 are
shared between datatypes and codatatypes. The code is integrated in the
development version of the solver and is expected to be part of the CVC4~1.5 release.
%
An evaluation on %hand-crafted examples and on
problems generated from Isabelle theories using the Sledgehammer tool
demonstrates the usefulness of the approach (Section~\ref{sec:experimental-results}).

%  * useful both for proving and for model finding

%\ref{sec:examples}

%  * benchmarking is often an issue -- esp. codatatypes
%
%Polymorphic types, nested (co)recursion, and datatype--codatatype mixtures fall

%  * setting: FOL
%    * core procedure is restricted to ground
%      * but theory solver cooperates
%    * still, universal conjectures fall into the ground fragment via negation
%      and skolemization (or, alternatively, herbrandization)

%  * codatatypes were added later, motivated by the use of SMT solvers as
%    backends to proof assistants (more specifically, CVC4 to Isabelle/HOL)

%  * setting :
%    * universal formulas
%    * many-sorted logic
%   * mutually (co)recursive types with constructors, selectors, and
%      discriminators

%  * codatatypes: from a theoretical and implementational point of view, like
%      datatypes but:
%    * infinite values (infinitely many nested constructors)
%    * codatatypes are never empty (e.g. finite streams are rejected)

%\[
%      \keyw{codatatype}\; \,\ty{llist} \,=\, \const{LNil} \,\mid\, \const{LCons}(\ty{int},\, \ty{llist})
%\]

%  * consider a natural fragment---datatypes as supported in modern SMT solvers
%    and the SMT-LIB 2 standard, and codatatypes as their duals
%    * mutual recursion, but no polymorphism, nested recursion
%  * integrated with Nelson-Oppen

% * SMT-Lib

%  * one implication is that if $m$ equals $ES(n)$ and $n$ equals $ES(m)$, necessarily
%    $m$ and $n$ must be equal.

%  * perhaps the most commonly used codatatype is that of lazy lists or sequences.
%    using a syntax similar to Standard ML, Haskell, or SMT-LIB

%  * less briefly: codatatypes and why they are useful
%    * in Agda, Coq, Matita -- recently also in Isabelle/HOL \cite{nipkow-et-al-2002}
%    * but not in SMT-LIB 2 \cite{barrett-et-al-2010}

\paragraph{Related Work.}
Although it was written several years ago, the account of related work in
Barrett et al.\ \cite{barrett-et-al-2007} is still largely up to date.
Since then, datatypes have been added to Z3 in unpublished work by Leonardo de
Moura and to a SPASS-like prototype prover called Pirate by Daniel Wand.
%\cite{wand-weidenbach-201x}.
Closely related is the support for structural
induction in CVC4 by Reynolds and Kuncak \cite{reynolds-kuncak-2015} and in
Pirate by Wand and Weidenbach \cite{wand-weidenbach-201x}, which depends on a
notion of datatype.

%     * point to Barrett et al. for SMT datatypes
%       * about their own work, they say: "our focus is on generality and
%         efficiency rather than immediacy of implementation"
%       * (deal more directly with finite sorts than Barrett et al., Section 6.1)
%     * SPASS-Pirate
%     * additional ones since then (e.g. strings?)
%     * anything about codatatypes?
%       * proof assistants like Agda, Coq, etc. have them
%       * Dafny, CoALP
%       * also a lot of theoretical research, some of which is loosely connected,
%         e.g. decision procedure for corecursive functions (Henning in Nijmegen)
% 
%     * ODDITY: Oppen 1980: single-constructor, recursive -- infinite values?

\paragraph{Conventions.}
The setting is a monomorphic (or many-sorted) first-order logic.
A signature $\Sig = (\Types, \Funcs)$ consists of a set of types $\Types$ and a
set of function symbols $\Funcs$. Types are simply atomic sorts, with no
structure, and interpreted by nonempty domains. The set~$\Types$ must contain a
distinguished type \ty{bool} interpreted as the set of truth
values $\{\bot, \top\}$. %, and may contain other interpreted types (e.g., \ty{int}, \ty{real}).
The only predicate is equality ($\teq$) and is considered a logical symbol.
Other predicates can be represented as functions that return $\ty{bool}$.
The metavariables $\delta, \tau$ range over types, with $\delta$ reserved
for datatypes and codatatypes.

Function symbols are written in a sans-serif font (e.g., $\const{f}$, $\const{g}$) to
distinguish them from variables (e.g., $x$, $y$). Names starting with an uppercase
letter (e.g.,
$\const{S}$, $\const{SCons}$) are reserved for constructors. With each function symbol \const{f}
is associated a list of argument types $\tau_1,\ldots,\tau_n$ (with $n \ge 0$)
and a return type $\tau$. This connection can be expressed compactly as
$\const{f} : \tau_1 \times \cdots \times \tau_n \to \tau$,
which collapses to $\const{f} : \tau$ if $n = 0$.
For a term $t$, the notation $t : \tau$ indicates that $t$ has type $\tau$.
Functions are invoked in the standard way, with $\const{f}(t_1,\ldots,t_n)$
applying the $n$-ary function symbol
\const{f} to $n$ well-typed arguments $t_1 : \tau_1$, \ldots, $t_n :
\tau_n$. Nullary function symbols are called constants and can appear without
parentheses in terms.
%
Finally, the notation $\bar x$ abbreviates a list or tuple $x_1,\ldots,x_n$.
% and $\bigwedge_i \varphi_i$ abbeviates a conjunction $\varphi_1 \mathrel\land \cdots \mathrel\land \varphi_n$.

%* although nothing prevents composing the decision procedure with theories
%  providing polymorphic types (parametric sorts), such as for arrays (e.g., $\ty{array}(\alpha,\beta)$)

\section{Theory of (Co)datatypes}
\label{sec:theory-of-co-datatypes}

%    (terminology: freely-generated, inductive, algebraic, ..., sometimes
%    with different meanings; we'll clarify below what we use)

We fix a signature $\Sig = (\Types, \Funcs)$. The types are partioned into
$\Types = \Data \mathrel{\uplus} \Codata \mathrel{\uplus} \Nondata$, where $\Data$ are the
\emph{datatypes}, $\Codata$ are the \emph{codatatypes}, and $\Nondata$ are the remaining
\emph{ordinary types}. The functions are partitioned into $\Funcs = \Ctr
\mathrel{\uplus} \Sel$, where $\Ctr$ are the \emph{constructors} and $\Sel$ are the
\emph{selectors}; there is no need to consider other function symbols, because they can
be abstracted away as variables when combining theories.
%
In an SMT problem, the signature is normally given by specifying the
uninterpreted types in any order, the (co)datatypes with their constructors
and selectors in groups of mutually (co)recursive groups of (co)datatypes, and
finally any other function symbols.

A (co)datatype specification consists of $l$~mutually recursive types which are
either all datatypes or all codatatypes. Polymorphic types, nested
(co)recursion, and datatype--codatatype mixtures fall outside this fragment%
\dotReportFootnote{%
In principle, rank-1 (top-level) polymorphism \cite{blanchette-paskevich-2013}
should not raise any special difficulties. Nesting datatypes inside datatypes,
and likewise for codatatypes, can be reduced to the mutual case
\cite{gunter-1993-not}. So the only genuinely interesting cases missing are
mixed nested (co)recursion as well as
(co)recursion through a non-(co)datatype (both of which make sense
\cite{blanchette-et-al-2014-codata}).}
In the presentation, we allow ourselves some metalevel parameterization
% at the metalevel
through subscripts---for example, $\ty{stream}_{\,\tau}$ denotes a
family of ground types including
$\ty{stream}_{\,\ty{int}}$, $\ty{stream}_{\,\ty{bool}}$,
and \smash{$\ty{stream}_{\,\ty{stream}_{\,\ty{real}}}$}.

Each datatype $\delta$ is equipped with
$m \ge 1$ constructors, and each constructor for $\delta$ takes zero or more
arguments and returns a $\delta$ value. The argument types must be either
ordinary, among the already know (co)datatypes, or among the (co)datatypes being
introduced.
%
To every argument corresponds a selector. The introduced names for the (co)data\-types, the
constructors, and the selectors must be distinct and different from already
introduced ones%
\dotReportFootnote{It can be convenient to specify the same selector
for several constructors associated with the same (co)data\-type,
as long as the argument types coincide. % \cite[Section~3]{blanchette-et-al-2014-codata}.
However, this is disallowed by SMT-LIB 2, so we do not consider it here.}
Schematically:
%
\[
\begin{aligned}[t]
(\keyw{co})\keyw{datatype}\;\,
  \delta_1 & {}=\, \const{C}_{1}\rlap{${}_{1}$}\phantom{{}_{m}}(\bigl[\const{s}_{11}^1{:}\bigr]\; \tau_{11}^1, \,\ldots,\, \bigl[\const{s}_{11}^{n_{11}}{:}\bigr]\; \tau_{11}^{n_{11}}) & \\
           & {}\;\phantom{=\,}\;{} \smash{\,\,\,\vdots} \\[-\jot] % {}\;\phantom{=}\llap{\ensuremath{\mid}}\; \cdots \\
           & {}\;\phantom{=\,}\llap{\ensuremath{\,\mid\,}}\; \const{C}_{1m}(\bigl[\const{s}_{1m}^1{:}\bigr]\; \tau_{1m}^1, \,\ldots,\, \big[\const{s}_{1m}^{n_{1m}}{:}\big]\; \tau_{1m}^{n_{1m}}) \\[-1\jot]
   \smash{\vdots\,\,\,} \\[-1\jot]
  \keyw{and}\; \,\delta_l & =\, \ldots
\end{aligned}
\]
%
with
$\const{C}_{i\negvthinspace j} : \tau_{i\negvthinspace j}^1\times\cdots\times\tau_{i\negvthinspace j}^{\,k_{\smash{i\negvthinspace j}}} \to \delta_i$
and $\const{s}_{i\negvthinspace j}^{\,k} : \delta_i \to \tau_{i\negvthinspace j}^{\,k}$. Defaults are assumed for
the selector names if they are omitted.

For types with several constructors, it is customary to provide discriminators
$\const{d}_{i\negvthinspace j} : \delta_i \to \ty{bool}$. However,
it is not necessary to extend the signature:
$\const{d}_{i\negvthinspace j}(x)$ can be seen as an abbreviation for
$x = \const{C}_{i\negvthinspace j}\bigl(\const{s}_{i\negvthinspace j}^1(x), \ldots, \const{s}_{i\negvthinspace j}^{\,n_{\smash{{i\negvthinspace j}}}}(x)\bigr)$.
This will simplify the presentation of the decision procedure.

Here are a few examples of legal specifications of (co)datatype families:
\[\begin{aligned}[t]
      \keyw{datatype}\;\, \ty{tree}_{\,\tau} & \,=\, \const{Node}(\tau,\, \ty{forest}_{\,\tau}) \\[-\jot]
      \keyw{and}\;\, \ty{forest}_{\,\tau} & \,=\, \const{FNil} \,\mid\, \const{FCons}(\ty{tree}_{\,\tau},\, \ty{forest}_{\,\tau}) \\%[-.5\jot]
      \keyw{codatatype}\; \,\ty{llist}_{\,\tau} & \,=\, \const{LNil} \,\mid\, \const{LCons}(\tau,\, \ty{llist}_{\,\tau})
\end{aligned}
\]

Because the types are inhabited (nonempty), a datatype specification is
admissible only if a ground constructor term can be exhibited that belongs to
that datatype. This rules out ill-founded specifications such as
\[\keyw{datatype}\;\, \ty{fstream} \,=\, \const{FSCons}(\ty{int},\,\ty{fstream})\]
For codatatypes, no such check is necessary because there is always a term,
finite or infinite, that witnesses nonemptiness.
%Given the specification
%
%\[\keyw{codatatype}\;\, \ty{stream} \,=\, \const{SCons}(\ty{int},\,\ty{stream})\]
%
%the infinite value $\const{SCons}(0, \const{SCons}(0, \ldots))$ witnesses
%nonemptiness.

Datatypes and codatatypes share basic properties pertaining to constructors and
selectors. All properties below are implicitly universally quantified and range
over all $i$, $j$, $\jPrime$, and $k$ within bounds:
% and to all possible splits of the
%$n$-ary constructor $\const{C}_{i\negvthinspace j}$'s argument list into $\bar x,
%y, \bar z$:
%
\[
\begin{aligned}[t]
\text{Distinctness:}\quad
  & %\forall \bar x, \bar y.\;\,
    \const{C}_{i\negvthinspace j}(\bar x) \tneq \const{C}_{i\negvthinspace \jPrime}(\bar y) \quad\text{if $j \not= \jPrime$}
  \\
\text{Injectivity:}\quad
  & %\forall x_1,\ldots,x_{n_{i\negvthinspace j}} y.\;\,
    \const{C}_{i\negvthinspace j}(x_1,\ldots,x_{n_{i\negvthinspace j}}) \teq \const{C}_{i\negvthinspace j}(x_1,\ldots,x_{k-1},y,x_{k+1},\ldots,x_{n_{i\negvthinspace j}}) \longrightarrow x_k \teq y
  \\
\text{Exhaustiveness:}\quad
  & \is{C}_{i1}(x) \mathrel\lor \cdots \mathrel\lor \is{C}_{im_i}(x)
  \\
\text{Selection:}\quad
  & s_{i\negvthinspace j}^k(\const{C}_{i\negvthinspace j}(x_1,\ldots,x_{n_{i\negvthinspace j}})) = x_k
\end{aligned}
\]
%
Expressed in the algebraic jargon, exhaustiveness ensures that ``no junk''
exists, whereas distinctness and injectivity ensure that ``no confusion''
arises.

Datatypes are additionally characterized by an induction axiom schema:
%
\[
\begin{aligned}[t]
\text{Induction:}\quad
\AXC{\strut$\bigwedge_{i,j} \forall x_1 \ldots \vthinspace x_{n_{i\negvthinspace j}}.\; \bigl(\bigwedge_{\,k\,} \mathit{IH}_{i\negvthinspace j}^k[x_k]\bigr) \longrightarrow P_i[C_{i\negvthinspace j}(x_1,\ldots,x_{n_{ij}})]$}
\UIC{\strut$\bigwedge_{i} P_i[v_i]$}
\DP
\end{aligned}
\]
where the induction hypothesis $\mathit{IH}_{i\negvthinspace j}^k(x)$
denotes either $P_{\iPrime}(x)$ if there exists some $i$ such that this is type
correct or else $\top$.
%
The axiom schema ensures that we get a smallest model. For example,
for a datatype of natural numbers constructed from $\const{Z}$ and $\const{S}$,
this rules out nonstandard models, which could contain cyclic values (e.g.,
an $n$ such that $n \teq \const{S}(n)$) or even infinite acyclic values
$\const{S}(\const{S}(\ldots))$.

For codatatype, the dual notion is that of a coinduction principle that
depends on witnesses $R$ that are required to be bisimulations:
%
\[
\begin{aligned}[t]
\text{Coinduction:}\quad
\AXC{\strut$\begin{gathered}\textstyle \bigwedge_i R_i[v_i, w_i] \\[-\jot]\textstyle
\bigwedge_i \forall v\; w.\;\, R_i[v, w] \longrightarrow
  \bigwedge_j \const{d}_j(v) \teq \const{d}_j(w)
  \mathrel\land
  \const{d}_j(v) \longrightarrow \bigwedge_k \const{s}_{i\negvthinspace j}^{\,k}(v) \sim \const{s}_{i\negvthinspace j}^{\,k}(w)
\end{gathered}$}
\UIC{\strut$\bigwedge_i v_i \teq w_i$}
\DP
\end{aligned}
\]
where $x \sim y$ denotes either $R_i[x, y]$ if there exists some $i$ such that
this is type correct or $x \teq y$ otherwise.

FIXME: Find out what ensures that codatatypes have infinite values.

This axiom schema captures the idea that two values that yield the same
observations must be equal, where the observations are made by using the
selectors and discriminators.


% TODO: where does this go?
%      * when looking at the universal ground (?) theory:
%        enough to consider acyclicity -- no way to specify infinite objects
%        otherwise

%    * codatatypes:
%      * coinduction axiom (schema)
%        * consequence: infinite objects are allowed, but
%          two objects yielding the same observations must be equal

      * again: when looking at the universal ground (?) theory, enough to
        consider bisimilarity/bisimulation

specifies the 



  * how to deal with "wrong" selectors, e.g.
        hd(nil1) = hd(nil2)?
      * leave them unspecified; hence hd(nil1) = hd(nil2) in some models,
        and not in other models




Datatypes can be defined semantically as the initial model of an equational
specification of the selector--constructor equations. This is the view followed
by Barrett et al.\ \cite{barrett-et-al-2010}. A disadvantage with this approach
is that it does not naturally account for selectors applied to wrong
constructors. Barrett et al.\ address this by parameterizing the construction by
default values, but these give rise to spurious equalities between unrelated
terms---for example, $\const{s}_{11}(\const{C}_2) \teq \const{s}_{11}(\const{C}_3)$.
This could be corrected, but the added
complexity seems to suggest that selectors are better specified axiomatically.

A related semantic view of datatypes is as initial algebra. Codatatypes are then
defined dually as a final coalgebra. The datatypes are generated by their
constructors, whereas the codatatypes are viewed through their selectors
\cite{xxx}. By uniformly focusing on the constructors, the axiomatic approach
emphasizes the commonality between datatypes and codatatypes, while sacrificing
a theoretically fruitful notion of duality.


    semantically, $k$ types are mutually (co)recursive if their dependency graph
    (x -> y if x is the type of an argument to one of y's constructors) is
    strongly connected

    (co)datatypes can be declared together as mutually (co)recursive even if
    they are not actually (co)recursive

    the semantic notion is more fruitful and the one we will focus on in the
    sequel

    Also, nothing forbids specifications with no (co)recursion, e.g.

      datatype enat = Nat(nat) | Infty
      codatatype complex = Complex(re: real, im: real)

    In this case, it makes no difference whether the type is introduced as a
    datatype or as a codatatype. Without loss of generality, we consider that
    these types are datatypes instead of codatatypes.


Degenerate Codatatypes

    Consider

      codatatype a = A(a)

    This is a finite codatatype, with a single value, which is infinite:
    $\mu a. A(a)$
    
    We need to detect those finite codatatypes. They are easy to
    characterize semantically.

    Lemma D.1. The only possible finite cardinality for the domain interpreting
    a (corecursive) codatatype is 1.

    Proof.
      Assume you have at least 2 different values of a codatatype.
      They differ at one point.
      * 
    Qed

    An immediate consequence by the distinctness axiom is that these types have
    necessarly one constructor, and that all arguments are of types of
    cardinality 1.

    Easy case: $k$ mutually recursive codatatypes, each equipped with one
    constructor, all of which take each other in arguments in various
    combinations, with potential other types that are known to have cardinality
    1. e.g.

      codatatype b = B b c b
             and c = C c b c

    Medium case: like above, but some of the arguments are other types not
    participating in the corecursion that are known to have cardinality 1, e.g.

      codatatype d = D unit d d unit

    where "unit" is a datatype with the single constructor "Unity : unit".

    Though case: like above, but with any other types where it's not clear
    whether it could have cardinality one or not.

      type e
      codatatype f = F e f f unit


\section{The Calculus}
\label{sec:the-calculus}

  * SMT background

\subsection{The Ground Case}

  * Rewriter
  * Actual calculus

  * Correctness

\rem{Discuss signature $\Sig$, theory $\thD$}
\rem{DPLL(T) : we can restrict ourselves to conjunctions.}
This section presents a calculus for determining the satisfiability of conjunctions of $\thD$-constraints.

Our calculus consists of derivation rules that operate on a set $\Ec$ of equalities and disequalities between $\Sig$-terms.
We will write $\tEc$ to denote the set of $\Sig$-terms occurring in $\Ec$.
%We will commonly denote tuples of terms $( t_1, \ldots, t_n )$ in bold font, as $\vec t$.
We assume that all $\Sig$-terms in $\Ec$ are \emph{normalized}, meaning that all subterms of the form $s^i_j( \const{C}_j( \vec t ) )$
are replaced by $t_i$, and moreover assume that all additional constraints added to $\Ec$ are normalized in this manner.

We present the calculus in three parts.
In the first part we compute the bidirectional closure of $\Ec$,
in the second part we make inferences based on cyclicity and bisimilarity,
and in the third part (when necessary) we branch on constructor types for various terms in $\tEc$.
Following the conventions from~\cite{}, 
the derivation rules of our calculus are given in \emph{guarded assignment form},
where a rule can be applied to $\Ec$ if it meets all of the specified preconditions for $\Ec$.
The conclusion of a rule either describes equalities to be added to $\Ec$ (in which case we will call an application of it to be \emph{non-terminal}),
or is $\bot$ (in which case we will call an application of it to be \emph{terminal}).
A rule may have multiple conclusions separated by $\parallel$, which denotes a non-deterministic branching.
An application of a rule is \emph{redundant} if it is non-terminal and at least one branch in its conclusion does not add a new equality to $\Ec$.

\begin{figure}[t]
\centering
\begin{tabular}{c}
\rn{Refl}
\(
\inferrule{
  t \in \tEc
}{
  \Ec := \Ec, t \teq t
}
\)
\qquad
\rn{Symm}
\(
\inferrule{
 t_1 \teq t_2 \in \Ec
}{
 \Ec := \Ec, t_2 \teq t_1
}
\)
\qquad
\rn{Conflict}
\(
\inferrule{
  t_1 \teq t_2, t_1 \tneq t_2 \in \Ec
}{
  \bot
}
\)
\\[3.7ex]
\rn{Trans}
\(
\inferrule{
  t_1 \teq t_2, t_2 \teq t_3 \in \Ec
}{
  \Ec := \Ec, t_1 \teq t_3
}
\)
\qquad
\rn{Cong} 
\(
\inferrule{
  \vec t \teq \vec u \in \Ec \quad f( \vec t ), f( \vec u ) \in \tEc
}{
  \Ec := \Ec, f( \vec t ) \teq f( \vec u )
}
\)
\\[3.7ex]
\rn{Unify$_1$} 
\(
\inferrule{
  \const{C}_1( \vec t ) \teq \const{C}_1( \vec u ) \in \Ec
}{
  \Ec := \Ec, \vec t \teq \vec u
}
\)
\qquad
\rn{Unify$_2$} 
\(
\inferrule{
  \const{C}_1( \vec t ) \teq \const{C}_2( \vec u ) \in \Ec
}{
  \bot
}
\)
\end{tabular}
\caption{Rules for bidirectional closure.
}
\label{fig:cc-rules}
\end{figure}

\paragraph{Step 1: Compute Birectional Closure}
Figure~\ref{fig:cc-rules} gives the basic rules of our calculus.
Together with the rules \rn{Refl}, \rn{Symm}, \rn{Trans}, the rule \rn{Cong} computes the (upwards) congruence closure,
while the rules \rn{Unify$_1$} and \rn{Unify$_2$} together compute (downwards) unification.
In the unification rules, additional equalities are inferred based on the injectivity of constructors by \rn{Unify$_1$},
and failures to unify equated terms are recognized by \rn{Unify$_2$}.
The rule \rn{Conflict} recognizes when an equality and its negation both occur in $\Ec$, in which case $\Ec$ has no model.

\begin{figure}[t]
\centering
\begin{tabular}{c}
\rn{Cyclic}
\(
\inferrule{
  t : \tau
  \quad
  \tau \in \Data
  \quad
  %\ttpath{\Ec}{\ec{t}}{\ec{t}} \neq \emptyset
  \Val \ec{t} = \mu x. t'
  \quad
  x \in FV( t' )
}{
  \bot
}
\)
\\[3.7ex]
\rn{Bisimilar}
\(
\inferrule{
 t_1, t_2 : \tau
 \quad
 \tau \in \Codata
 \quad
 %\tpath{\Ec}{\ec{t_1}} = \tpath{\Ec}{\ec{t_2}}\sigma \neq \emptyset
 \Val \ec{t_1} \vsim \Val \ec{t_2}
}{
 \Ec := \Ec, t_1 \teq t_2
}
\)
\end{tabular}
\caption{Rules for cyclicity and bisimilarity.
}
\label{fig:ab-rules}
\end{figure}

\paragraph{Step 2: Apply cyclicity and bisimilarity.}
In this step,
we assume that $\Ec$ is saturated with respect to the rules in Figure~\ref{fig:cc-rules}, that is,
no non-redudant application of one of its rules can be applied to $\Ec$.
When this is the case, it is easy to see that $\Ec$ induces an equivalence relation over $\tEc$ such that two terms $t_1$ and $t_2$ are equivalent if and only if $t_1 \teq t_2 \in \Ec$.
Thus, we will in the following consider $\Ec$ as a set of equivalence classes of terms. 
For term $t \in \tEc$, we will write $\ec{t}$ to denote the equivalence class in $\Ec$ that containing $t$.

Recall that the $\mu$-notation can be used to represent (possibly cyclic) terms and values,
for instance, $\mu x. \const{C}( \const{0}, x )$ represents the cyclic value $\const{C}( \const{0}, \const{C}( \const{0}, \ldots ))$.
Formally, we recursively define a $\mu$-term is either of the form
$\mu x. \const{C}( \vec t )$ for some constructor $\const{C} \in \Ctr$ and $\mu$-terms $\vec t$, 
or a variable $x$.
We consider only $\mu$-terms that are \emph{well-typed}, which we define recursively:
if the type of $\const{C}$ is $\vec \tau \rightarrow \upsilon$, 
then if $\vec v$ are well-type $\mu$-terms under the assumption that $x$ has type $\upsilon$,
then $\mu x. \const{C}( \vec v )$ is a well-typed term of type $\upsilon$.
We say a $\mu$-term is \emph{closed} if it contains no free variables.
We write $t \vsim s$ if $\mu$-terms $t$ and $s$ are syntactically equivalent modulo renaming of $\mu$-bound variables.
For convienience, we will use $\mu$-terms to refer to (classes of) values for both co-datatype and datatype terms,
where in the latter case, a $\mu$-term with a bound variable denotes an invalid term.
%where the latter case adds the restriction on $\mu$-terms $t$ that no subterms of $t$ contain are bound variables.

At the beginning of this step, 
we compute a mapping $\Val$ from equivalence classes to $\mu$-terms.
Informally, the terms mapped to by $\Val$ describe the (class of) values that terms in each equivalence class can take in the models of $\Ec$. 
For each equivalence class $\ec{x}$ of $\Ec$, we associate a fresh variable $v_{\ec{x}}$ of the same type as $x$ not occurring in $\tEc$,
and initially say that $\Val$ contains $\ec{x} \mapsto v_{\ec{x}}$ for each equivalence class $\ec{x}$ of $\Ec$ 
(in other words, there are initially no constraints on the values for any equivalence class).
Then, $\Val$ is updated by applying the following rule exhaustively:

\(
\inferrule{
  v_{\ec{x}} \in FV( \Val )
  \quad
  C( t_1, \ldots, t_n ) \in \ec{x}
  \quad
  C \in \Ctr
}{
  \Val := \Val \{ v_{\ec{x}} \mapsto \mu v_{\ec{x}}. C( v_{\ec{t_1}}, \ldots, v_{\ec{t_n}} ) \}
}
\)

Here, we write $FV( \Val )$ to denote the free variables occurring in $\Val$, which
excludes variables that occur beneath $\mu$-binders.
It is straightforward to show that the height of terms produced as a result of this rule
is bounded by the number of equivalence classes of $\Ec$,
and thus our construction of $\Val$ is terminating.

\begin{example}
Say that $\Ec$ contains (distinct) equivalence classes $\ec{x}$, $\ec{y}$, $\ec{z}$ and $\ec{w}$ where $\const{C}(z,x) \in \ec{y}$ and $\const{C}(w,y) \in \ec{x}$.
A possible sequence of applications of the above rule is shown below.
In the first column, we show the equivalence class that was considered,
and in the second column, we show the state of $\Val$.
\[\begin{array}{|l|@{\hspace{.5em}}l@{\hspace{.5em}}l@{\hspace{.5em}}l@{\hspace{.5em}}l|}
\hline
\text{Eqc} & \multicolumn{3}{c}{\Val} & \ 
\\
\hline
& \{ & \ec{x} \mapsto v_{\ec{x}}, & \ec{z} \mapsto v_{\ec{z}}, & \\
&    & \ec{y} \mapsto v_{\ec{y}}, & \ec{w} \mapsto v_{\ec{w}} & \} \\
\ec{x}
& \{ & \ec{x} \mapsto \mu v_{\ec{x}}. \const{C}( v_{\ec{w}}, v_{\ec{y}} ), & \ec{z} \mapsto v_{\ec{z}}, & \\
&    & \ec{y} \mapsto v_{\ec{y}}, & \ec{w} \mapsto v_{\ec{w}} & \} \\
\ec{y}
& \{ & \ec{x} \mapsto \mu v_{\ec{x}}. \const{C}( v_{\ec{w}}, \mu v_{\ec{y}}. \const{C}( v_{\ec{z}}, v_{\ec{x}} ) ), & \ec{z} \mapsto v_{\ec{z}}, & \\
&    & \ec{y} \mapsto \mu v_{\ec{y}}. \const{C}( v_{\ec{z}}, v_{\ec{x}} ), & \ec{w} \mapsto v_{\ec{w}} & \} \\
\ec{x}
& \{ & \ec{x} \mapsto \mu v_{\ec{x}}. \const{C}( v_{\ec{w}}, \mu v_{\ec{y}}. \const{C}( v_{\ec{z}}, v_{\ec{x}} ) ), & \ec{z} \mapsto v_{\ec{z}}, & \\
&    & \ec{y} \mapsto \mu v_{\ec{y}}. \const{C}( v_{\ec{z}}, \mu v_{\ec{x}}. \const{C}( v_{\ec{w}}, v_{\ec{y}} ) ), & \ec{w} \mapsto v_{\ec{w}} & \} \\
\hline
\end{array}\]
Informally, this indicates that the values for $x$ (resp. $y$) in models of $\Ec$
are of the form $\const{C}( w, \const{C}( z, \ldots ))$ (resp. $\const{C}( z, \const{C}( w, \ldots ))$) for some value of $w$ and $z$.
$\Box$
\end{example}

Given $\Val$, the rules for cyclicity and bisimilarity (shown in Figure~\ref{fig:ab-rules}) can be stated as follows.
For cyclicity, if there is an equivalence class $\ec{t}$ of datatype type whose class of values $\Val \ec{t} = \mu x. t'$ are cyclic,
as indicated by the assumption $x \in FV( t' )$,
then we can conclude that $\Ec$ is unsatisfiable.
For bisimilarity, if there are two equivalence classes $\ec{t_1}$ and $\ec{t_2}$ 
of co-datatype type whose classes of values $\Val \ec{t_1}$ and $\Val \ec{t_2}$ are equivalent modulo renaming of $\mu$-bound variables,
then we can conclude $t_1 \teq t_2$.
We demonstrate the bisimilarity rule concretely with the following example.

\begin{example}
Let $\const{C}$ be a constructor of type $\tau_1 \times \tau_2 \rightarrow \tau_2$,
and let $\Ec$ be the set $\{ x \teq \const{C}(y,\const{C}(y,x)) \}$.
After applying the rules in Figure~\ref{fig:cc-rules} to completion, the equivalence classes of $\Ec$ are
$\{ x, \const{C}(y,\const{C}(y,x)) \}$, $\{ \const{C}(y,x) \}$, and $\{ y \}$.
We then construct $\Val$ using the aforementioned steps, after which we obtain:
\[\begin{array}{l@{\hspace{.5em}}l@{\hspace{.5em}}r@{\hspace{.5em}}l@{\hspace{.5em}}r@{\hspace{.5em}}l}
\Val \ec{x} & = & 
\mu v_{\ec{x}}. & \const{C}( v_{\ec{y}}, & \mu v_{\ec{\const{C}(y,x)}}. & \const{C}( v_{\ec{y}}, v_{\ec{x}} ) ) \\
\Val \ec{\const{C}(y,x)} & = & 
\mu v_{\ec{\const{C}(y,x)}}. & \const{C}( v_{\ec{y}}, & \mu v_{\ec{x}}. & \const{C}( v_{\ec{y}}, v_{\ec{\const{C}(y,x)}} ) )
\end{array}\]
Notice that $\Val \ec{x}$ and $\Val \ec{\const{C}(y,x)}$ are syntactically equivalent for the renaming
$\{ v_{\ec{x}} \mapsto v_{\ec{\const{C}(y,x)}}, v_{\ec{\const{C}(y,x)}} \mapsto v_{\ec{x}} \}$,
and thus our calculus may infer $x \teq \const{C}(y,x)$.
Intuitively, this equality holds, since the values of $x$ and $\const{C}( y, x )$ are observationally equivalent for any value of $y$.
\qed
\end{example}


\begin{comment}
To explain the rules in Figure~\ref{fig:ab-rules}, we introduce the following notions.
First, an edge $\ec{t_1} \rightarrow^{C}_n \ec{t_2}$ is a transition between two equivalence classes $\ec{t_1}$ and $\ec{t_2}$ 
(which we will call its \emph{source} and \emph{destination} respectively),
labeled by a constructor $C$ and integer $n$.
We say that edge $\ec{t_1} \rightarrow^{C}_n \ec{t_2}$ is \emph{induced by $\Ec$} if and only if $C( \vec u ) \in \ec{t_1}$ for some $\vec u$ and $\ec{t_2} = \ec{u_n}$.
In other words, $t_1$ is equivalent to a $C$-application whose $n^{th}$ argument is equivalent to $t_2$.
A \emph{path} $p$ is a non-empty ordered list of edges $e_1, \ldots e_n$ such that the destination of $e_i$ is the source of $e_{i+1}$ for $i = 1, \ldots (n-1)$,
and the sources of $e_1, \ldots, e_n$ are distinct.
We say that path $p$ is \emph{induced by $\Ec$} if and only if each of its edges are induced by $\Ec$.
Notice that since $\Ec$ contains a finite set of equivalence classes, all paths induced by $\Ec$ have finite length.
We call the \emph{source} of a path is the source of its first edge, and the \emph{destination} of a path is the destination of its last edge.
We say a path $p$ is \emph{maximal} if its destination $\ec{t}$ is either
the source of an edge in $p$, 
or does not contain an application of a non-nullary constructor (including the case when $t$ is not of datatype/codatatype type).
The set $\ttpath{\Ec}{\ec{t_1}}{\ec{t_2}}$ is the smallest set containing all maximal paths with source $\ec{t_1}$ and destination $\ec{t_2}$ that are induced by $\Ec$.
The set $\tpath{\Ec}{\ec{t_1}}$ is the union of $\ttpath{\Ec}{\ec{t_1}}{\ec{t_2}}$ for all $t_2 \in \tEc$.
We will write, for instance, $\ec{t_1} \rightarrow^{C_1}_{n_1} \ec{t_2} \rightarrow^{C_2}_{n_2} \ec{t_3}$ 
as shorthand for the path containing an edge from $\ec{t_1}$ to $\ec{t_2}$, followed by one from $\ec{t_2}$ to $\ec{t_3}$.
%A set of paths is \emph{disjoint} if it does not contain two paths $p_1$ and $p_2$ such that $p_1 = p_2 \sigma$ for some $\sigma$.

The rule \rn{Cyclic} recognizes when a path exists from an equivalence class $\ec{t}$ to itself, as indicated
by the assumption $\ttpath{\Ec}{\ec{t}}{\ec{t}} \neq \emptyset$.
In this case, $\Ec$ entails that $t$ contains itself as a (strict) subterm,
and thus if $t$ is a datatype, $\Ec$ must be unsatisfiable.
The rule \rn{Bisimilar} recognizes when two equivalence classes $\ec{t_1}$ and $\ec{t_2}$ having co-datatype type are observationally equivalent.
In this rule, $\sigma$ is a complete mapping over the equivalence classes that occur as sources in the edges of paths in $\tpath{\Ec}{\ec{t_2}}$.
The rule applies if $\tpath{\Ec}{\ec{t_1}}$ is comprised of the paths $p \sigma$ for each (and only) the paths $p \in \tpath{\Ec}{\ec{t_2}}$,
in which case $t_1$ must be equal to $t_2$.
We demonstrate an application of this rule concretely with the following example.
\end{comment}


\begin{figure}[t]
\centering
\begin{tabular}{c}
\rn{Singleton}
\(
\inferrule{
  t, u : \tau \in \tEc
  \quad
  \tau \in \Codata,
  \mid \tau \mid = 1
}{
  \Ec := \Ec, t \teq u
}
\)
\\[3.7ex]
\rn{Split} 
\(
\inferrule{
  t : \tau \in \tEc 
  \quad 
  ( s( t ) \in \tEc, s \in \Sel^\tau ) 
  \text{ or } 
  ( \tau \in \Data, \tau \text{ finite } )
}{
  \Ec := \Ec, t \teq \const{C}_1( s^1_1( t ), \ldots, s^{a_1}_1( t ) ) \ror \ldots \ror \Ec := \Ec, t \teq \const{C}_n( s^1_n( t ), \ldots, s^{a_n}_n( t ) ) 
}
\)
\end{tabular}
\caption{Rules for splitting.  
%All pairs of terms whose type has cardinality 1 are entailed to be equal (the degenerate case).
%Constructors must be assigned for all terms $t$ if has a selector is applied to it, or if $t$ has finite datatype type.
}
\label{fig:split-rule}
\end{figure}

\paragraph{Step 3: Branching}
If neither a rule from Figure~\ref{fig:cc-rules} or Figure~\ref{fig:ab-rules} applies to $\Ec$, 
the rules from Figure~\ref{fig:split-rule} are applied.
The rule \rn{Singleton} handles the degenerate case when there are two terms from $\tEc$ having a singleton codatatype type,
in which case they must be equivalent.
Otherwise, in the case there is a selector term applied to $t$, or if $t$ has a finite datatype type, 
then the equivalence class of $t$ must contain an application of one of the constructors of $\tau$ (where $\Ctr^\tau = \{ C_1, \ldots C_n \}$), 
which is enforced by the rule \rn{Split}.

A \emph{derivation tree} is a tree whose nodes are sets of equalities, where non-root nodes are obtained by 
a non-redundant application of a derivation rule to its parent node.
A derivation tree is \emph{closed} if all of its leaf nodes are $\bot$.
A node is \emph{saturated} if no non-redundant application of a rule can be applied to it.
If there exists a closed derivation tree with root node $\Ec$, then we conclude that $\Ec$ is $\thD$-unsatisfiable.
If there exists a derivation tree with root node $\Ec$ that contains a saturated node, then we conclude that $\Ec$ is $\thD$-satisfiable. 

\paragraph{Correctness.}

\begin{lemma}[Termination] \label{lem:t}
All derivation trees are finite.
\end{lemma}
\begin{proof}
Consider a derivation tree with root node $\Ec$.
Let $S$ be the set of terms occurring as the argument of a selector in $\tEc$.
Let $T$ be the set of terms in $\tEc$ of finite datatype type.
For each term $t \in T$,
let $S^0_t$ be the set $\{ t \}$,
for $i \geq 0$ let $S^{i+1}_t =$ $S^i_t \cup \{ s( u ) \mid u : \upsilon \in S^i, \upsilon \in \Data, \upsilon \text{ finite}, s \in \Sel^{\upsilon}  \}$,
and let $S^\ast_t$ be the fixed point of this sequence.
We know this is a finite set for each $t$ since the values of $t$'s type are of finite size.
Let $S^\ast$ be the union of $S^\ast_t$ for all $t \in T$,
and let $\tcEc$ be the set of subterms of $\Ec \cup \{ C_i( s^1_i( t ), \ldots, s^{a_i}_i( t ) ) \mid t : \tau \in S \cup S^\ast, C_i \in \Ctr^\tau \}$.
In a derivation tree with root node $\Ec$, 
it can be shown by case analysis on the rules of the calculus that each non-root node $\Fc$ is such that 
$\mathcal{T}(\Fc) \subseteq \tcEc$, and moreover thus contains an equality between two terms from $\tcEc$ not occurring in its parent node.
Thus, the depth of a branch in a derivation tree with root node $\Ec$ is at most $\mid \tcEc \mid^2$,
which is finite since $\tcEc$ is finite.
\qed
\end{proof}

\begin{lemma}[Refutation Soundness] \label{lem:rs}
If there exists a closed derivation tree with root node $\Ec$, then $\Ec$ is unsatisfiable in $\thD$.
\end{lemma}
\begin{proof}
We prove this by structural induction on the (closed) derivation tree with root node $\Ec$.
First, if the derivation tree is an application of \rn{Conflict}, \rn{Unify$_2$}, or \rn{Cyclic},
then $\Ec$ is unsatisfiable in $\thD$.
For \rn{Conflict}, this is a consequence of equality reasoning.
For \rn{Unify$_2$}, this is a consequence of distinctness.
For \rn{Cyclic}, this is a consequence of induction. \rem{elaborate?}
If the children of $\Ec$ are closed derivation trees 
whose root node is the result of applying the rule \rn{Split} on term $t$ of type $\tau$,
then by the induction hypothesis $\Ec \cup t \teq C_i( s^1_i( t ), \ldots, s^{a_i}_i( t ) )$ is unsatisfiable
for each $C_i \in \Ctr^\tau$.
Since by exhaustiveness, all models of $\thD$ entail (exactly) one equality $t \teq C_i( s^1_i( t ), \ldots, s^{a_i}_i( t ) )$,
we know $\Ec$ is unsatisfiable in $\thD$.
Otherwise, the child of $\Ec$ is a closed derivation tree 
whose root node is $\Ec \cup t_1 \teq t_2$ obtained by applying one of the rules \rn{Refl}, \rn{Symm}, \rn{Trans}, \rn{Cong}, \rn{Unify$_1$}, \rn{Bisimilar}, or \rn{Singleton}.
In all cases, we have that $\Ec \models_{\thD} t_1 \teq t_2$.
For \rn{Refl}, \rn{Symm}, \rn{Trans}, \rn{Cong}, this is a consequence of equality reasoning.
For \rn{Unify$_1$}, this is a consequence of injectivity.
For \rn{Bisimilar}, this is a consequence of co-induction. \rem{elaborate?}
For \rn{Singleton}, clearly $t_1$ and $t_2$ must have the same value since the cardinality of their type is one.
By the induction hypothesis, we have $\Ec \cup t_1 \teq t_2$ is unsatisfiable in $\thD$, 
and thus $\Ec$ is unsatisfiable in $\thD$.
\qed
\end{proof}

It remains to show the inverse of the previous lemma, that when a derivation tree with root node $\Ec$ contains a saturated node $\Fc$,
then $\Ec$ is satisfiable $\thD$.

%and second show how to construct a valuation for the variables of $\Fc \cup \Gc$.

%\begin{lemma}
%\end{lemma}

%Given a set of disjoint paths $P$ where each $p \in P$
%we write $\interp{P}$ to denote the value

\rem{Revise : now $\Val$ is constructed by calculus.}

First, we require additional terminology concerning $\mu$-terms.
The \emph{interpretation of subvalue $u$ in $v$} is the value $v\interp{u}^\emptyset$ returned by the following recursive procedure,
where $x \mapsto \mu x. C( \vec t ) \in v$ indicates that $\mu x. C( \vec t )$ is the subvalue of $v$ that binds this occurrence of variable $x$.
\[\begin{array}{l@{\hspace{.5em}}l@{\hspace{.5em}}l@{\hspace{.5em}}l}
v\interp{x}^M & = & v\interp{\mu x. C( \vec t )}^M & x \not\in M, x \mapsto \mu x. C( \vec t ) \in v  \\
v\interp{x}^M & = & x & \text{otherwise} \\
v\interp{\mu x. C( \vec t )}^M & = & \mu x. C( v\interp{ \vec t }^{M \cup \{ x \}} ) & x \not\in M \\
v\interp{\mu x. C( \vec t )}^M & = & x & \text{otherwise}
\end{array}\]
Given a $\mu$-value $v$ of the form $\mu x. C( \vec w )$, 
a subvalue $u$ of $v$ is a \emph{bisimilar subvalue} if and only if $v\interp{u}^\emptyset \sim v$.
We say $v$ is \emph{normal} if and only if all of its bisimilar subvalues are $x$,
and all of its strict subvalues that do not contain $v$ are also normal.
For instance, the value $v$ of the form $\mu x. \const{S}( \mu y. \const{S}( x ) )$ is not normal, 
since 
$v\interp{\mu y. \const{S}( x )}^\emptyset =$ 
$\mu y. \const{S}( v\interp{x}^{\{y\}} ) =$ 
$\mu y. \const{S}( v\interp{\mu x. \const{S}( \mu y. \const{S}( x ) ) }^{\{y\}} ) =$ 
$\mu y. \const{S}( \mu x. \const{S}( v\interp{\mu y. \const{S}( x )}^{\{x,y\}} ) ) =$ 
$\mu y. \const{S}( \mu x. \const{S}( y ) )$,
which is equivalent to $v$ modulo the renaming $\{ x \mapsto y, y \mapsto x \}$.
For any $\mu$-value $v$ of the form $\mu x. C( \vec w )$, we may recursively construct a normal value $\nf{v}$
(which we will call the \emph{normal form for $v$})
that is observationally equivalent to $v$.
We construct $\nf{v}$ by replacing all of the bisimilar subvalues of $v$ with $x$,
and by replacing all of the non-normal closed subvalues of $v$ with their corresponding normal forms.
For instance, $\nf{(\mu x. \const{S}( \mu y. \const{S}( x ) ))} = \mu x. \const{S}( x )$.


\begin{lemma}[Solution Soundness] \label{lem:ss}
If there exists a derivation tree with root node $\Ec$ containing a saturated node, then $\Ec$ is satisfiable in $\thD$.
\end{lemma}
\begin{proof}
Let $\Fc_0$ be a saturated node in a derivation tree with root node $\Ec$.
We will construct a model $\M$ for a set of equalities $\Fc$ that is equivalent to $\Fc_0$, and where 
all equivalence classes of $\Fc$ contain at least one variable, and all selectors in $\Fc$ are applied to variables only.
The former comes with no loss of generality since new equalities of the form $y \teq t$ for fresh variable $y$ can be added to $\Fc$ without affecting its satisfiability,
The latter also comes with no loss of generality since nested applications of selectors in $\Fc_0$ can be replaced by fresh variables while adding additional equalities to $\Fc$.

We construct a model $\M$ of $\thD$ that interprets constructors and correctly-applied selectors in the obvious way,
interprets wrongly-applied selectors based on equality information in $\Fc$,
interprets the variables and $x$ of $\Fc$ based on the valuation $\Val$ which we constructed in step two of our calculus.

Recall that $\Val$ was constructed as a mapping from the equivalence classes of $\Fc$ to $\mu$-terms.
We must first \emph{complete} $\Val$ so that it maps equivalence classes only to closed $\mu$-terms, that is, terms containing no free variables.
This is done by exhaustively applying of the following rule:

\(
\inferrule{
  v_{\ec{x}} \in FV( \Val )
  \quad
  c \not\sim c' \text{ for all } c' \in \vrange(\Val)
}{
  \Val := \Val \{ v_{\ec{x}} \mapsto c \}
}
\)
Since this rule removes one variable from the set $FV( \Val )$ and does not add any additional variables to $FV( \Val )$, 
it can only be applied a finite number of times.

We first argue that $\Val$ contains only to ground values (which include closed $\mu$-terms), in other words, $FV( \Val ) = \emptyset$.
First, since \rn{Split} does not apply to $\Fc$,
all equivalence classes of finite type contain constructor terms.
Thus, all variables in $FV( \Val )$ have infinite type.
%\rem{Require : all co-datatypes either have infinite cardinality, or have cardinality 1.}





%It is clear that after applying these rules to completion, $\Val$ is a mapping from equivalence classes to ground values.

\begin{eqnarray} \label{eqn:m-bij-dt}
\Val \ec{x} = \Val \ec{y} \text{ if and only if } \ec{x} = \ec{y}
\end{eqnarray}

\begin{comment}
We assume that:
\begin{enumerate}
\item Each equivalence class of $\Fc$ contains at least one variable,
\item Each equivalence class $\ec{x}$ of $\Fc$ where $x : \tau$, $\tau \in \Nondata$ contains a constant,
\item Each equivalence class $\ec{x}$ of $\Fc$ where $x : \tau$, $\tau \in \Data \cup \Codata$ contains a constructor term.
\end{enumerate}
The first statement comes with no loss of generality since new equalities of the form $y \teq t$ for fresh variable $y$ can be added to $\Fc$ without affecting its satisfiability.
The second statement can be assumed for $x : \tau$, since $\tau$ is infinite.
Hence, we can assign constants for each such equivalence class.
Moreover, since $\Fc$ contains $\thD$-constraints only, these constants can be chosen arbitrarily.
The third statement can be assumed by \rem{TODO}.

For each equivalence class $e : \tau$, where $\tau \in \Nondata$ containing constant $c$,
$\Val(x) = c$ for each $x \in e$.
For each $e : \tau$, where $\tau \in \Data$ containing the constructor term $C( \vec u )$ where the equivalence classes $\ec{\vec u}$ contains the variables $\vec y$,
$\Val(x) = C( \Val( \vec y ) )$ for each $x \in e$.
Since \rn{Cyclic} does not apply, this definition is well-defined. 
For each $e : \tau$, where $\tau \in \Codata$, 
$\Val( x ) = \interp{ \tpath{\Fc}{e} }$ for each $x \in e$.
Since neither \rn{Cong} or \rn{Bisimilar} applies to $\Fc$, we have that for all variables $x$ and $y$:
\begin{eqnarray} \label{eqn:m-bij-dt}
\Val(x) = \Val(y) \text{ if and only if } \ec{x} = \ec{y}
\end{eqnarray}
\end{comment}

Now, we let $\M( x ) = \Val \ec{x}$ for each variable $x$ in $\Fc$.
We first show $\M$ satisfies all equalities in $t_1 \teq t_2 \in \Fc$, where $t_1$ and $t_2$ have type $\tau$.

If $\tau \in \Nondata$, $t_1$ and $t_2$ must be variables, and thus $\M( t_1 ) = \M( t_2 )$ by construction.

If $\tau \in \Data$,
we first show that $\M( t ) = \Val \ec{x}$ for all non-selector terms $t$ that occur in datatype equivalence classes $\ec{x}$.
We show this by induction on the size of $\Val \ec{x}$.
In the case where $t$ is a variable, then $\M( t ) = \Val \ec{ t } = \Val \ec{ x }$.
In the case where $t$ is a constructor term $C( \vec u )$, 
then $\Val \ec{x}$ must have been assigned by \rn{Ind} for some constructor term $C'( \vec u' ) \in \ec{x}$.
Since \rn{Unify$_2$} does not apply to $\Fc$, we have that $C = C'$.
Since \rn{Unify$_1$} does not apply to $\Fc$, we have that $\ec{\vec u} = \ec{\vec u'}$.
By the induction hypothesis, we have $\M( \vec u ) = \M( \vec u' )$, and thus $\M( t ) = C( \M( \vec u ) ) = C'( \M( \vec u ' ) ) = \Val \ec{ x }$.

We now show that $\M( t ) = \Val \ec{x}$ for all selector terms $s^j_k( y )$ that occur in datatype equivalence classes $\ec{x}$.
Since \rn{Split} does not apply, 
$\ec{y}$ must contain a term of the form $C_i( s^1_i( y ), \ldots, s^{a_i}_i( y ) )$ for some $i$.
Let $x_1, \ldots, x_n$ be variables in equivalence classes $\ec{s^1_i( y )}, \ldots, \ec{s^{a_i}_i( y )}$.
By the previous paragraph, we have $\M( y ) = \M( C_i( s^1_i( y ), \ldots, s^{a_i}_i( y ) ) )$,
which is $C_i( \Val \ec{ x_1 }, \ldots, \Val \ec{ x_{a_i} } )$.
If $i = k$, then $\M( t ) = \M( s^j_k( y ) ) = s^j_k( \M( y ) ) = \Val \ec{x_j}$, which is $\Val \ec{ x }$ since $\ec{x_j} = \ec{s^j_i( y )} = \ec{x}$.
If $i \neq k$, then $\thD$ does not constraint the value of $\M( t )$,
and since $s^j_k( \M( y ) )$ is otherwise unconstrained in our model construction since \rn{Cong} does not apply, 
we may interpret $s^j_k( \M( y ) )$ as $\Val \ec{ x }$. 
Thus, for all datatype equivalence classes $\ec{x}$, we have $\M( t ) = \Val \ec{x}$ for each term $t \in \ec{x}$, which implies $\M \models t_1 \teq t_2$.

If $\tau \in \Codata$, \rem{TODO}

We now show that all disequalities in $\Fc$ are satisfied by $\M$.
Say $t_1 \tneq t_2 \in \Fc$.
Since \rn{Conflict} does not apply, we know $t_1 \teq t_2 \not\in \Fc$ and thus $\ec{t_1}$ and $\ec{t_2}$ are distinct.
By the previous paragraph and statement~\ref{eqn:m-bij-dt}, $\M( t_1 ) \neq \M( t_2 )$, and thus $\M \models t_1 \tneq t_2$.

Since by assumption $\Fc$ contains only equalities and disequalities, we have $\M \models \Fc$,
and since $\Fc$ is a superset of $\Ec$, we have that $\Ec$ is satisfied by $\M$.
\qed
\end{proof}

By Lemmas~\ref{lem:t},~\ref{lem:rs}, and~\ref{lem:ss}, the calculus described in this section is sound and complete for $\thD$.

\subsection{Extension to Quantified Formulas}

Blah.

\section{The Theory Solver}
\label{sec:the-theory-solver}

  * Strategies
  * Implementation
    * mention that discriminators are their own function symbols
    * what is an SMT theory solver
    * sharing is caring (and other "refinements" on calculus)
    * theory combination more complicated (and Theorem Completeness too weak)
      * need something like the string paper
    * cooperation with Nelson-Oppen / integration into SMT solver
    * "mu" stuff
    * no "internal search"
  * Enumerator?
    * for model generation

%\section{Examples}
%\label{sec:examples}

\section{Experimental Results}
\label{sec:experimental-results}


\section{Conclusion}
\label{sec:conclusion}

We introduced a decision procedure for datatypes and codatatypes and implemented
it in the SMT solver CVC4. Our main theoretical contribution has been the
addition of codatatypes. These are not very difficult
per se, but there are tricky corner cases to take care of if we care about
completeness (which we do). On the practical side, we obtained interesting
results on benchmarks generated from Isabelle theories, including some rather
%mind-boggling
puzzling bisimulation proofs.

This work is part of a larger program that aims at enriching automatic
provers with more high-level features and reducing the gap between automatic and
interactive theorem proving. As future work, we want to try out CVC4 and its
(co)datatypes for higher-order model finding in Isabelle, as an
alternative to the counterexample generator Nitpick
\cite{blanchette-nipkow-2010}. We also see some opportunities to enrich CVC4
with recursive and corecursive functions. Finally, it might be possible to go
further in terms of supporting nested and mixed (co)recursion and quantified
formulas over (co)datatypes in SMT solvers.

\def\ackname{Acknowledgment}
\paragraph{\ackname.}
We owe a great debt to Clark Barrett and Cesare Tinelli for datatype case blah
blah blah.
%
Our present and former bosses, Viktor Kuncak, Stephan Merz, Tobias Nipkow,
Cesare Tinelli, and Christoph Weidenbach, have either encouraged the research on
codatatype or at least tolerated it, both of which we are thankful for.
%
Andrei Popescu helped clarify our thoughts about axiomatizing codatatypes.
Andreas Lochbihler and Peter Gammie shared their private codatatype-based
theories with us so we could include them in the benchmarks.
%
Blanchette's research was partially supported by the Deutsche
Forschungs\-gemein\-schaft (DFG) project
\relax{Hardening the Hammer} (grant Ni\,491\slash 14-1).

\bibliographystyle{splncs03}
\bibliography{bib}{}

\end{document}
