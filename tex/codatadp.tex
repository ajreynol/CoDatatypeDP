%envcountsect,
\documentclass[a4paper,oribibl,envcountsame,draft]{llncs}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{arydshln}
\usepackage[scaled=.82]{beramono}
\usepackage{booktabs}
\usepackage{bussproofs}
\usepackage{calc}
\usepackage{cite}
\usepackage{mathptmx}
%\usepackage{txfonts}
%\usepackage{mathrsfs}
%\usepackage{pifont}
%\usepackage{smallcap}
\usepackage{mathpartir} 
\usepackage{stmaryrd}
\usepackage{subfigure}
\usepackage[usenames]{color}
%\usepackage{graphicx}
%\usepackage{newcent}
\usepackage{textcomp}
%\usepackage{tipa}
\usepackage{units}
\usepackage{url}
\usepackage{version}
\usepackage[all]{xy}

\DeclareFontFamily{OT1}{pzc}{}
\DeclareFontShape{OT1}{pzc}{m}{it}{<-> s * [1.10] pzcmi7t}{}
\DeclareMathAlphabet{\mathscr}{OT1}{pzc}{m}{it}

\DeclareMathAlphabet{\mathcal}{OT1}{pzc}{m}{it}

\renewcommand{\vec}[1]{\boldsymbol{#1}}
\newcommand{\Ec}{\mathsf{E}}
\newcommand{\tEc}{\mathcal{T}(\Ec)}
\newcommand{\rn}[1]{\textsf{\small #1}}
\newcommand{\cvc}{\textsc{cvc}{\small 4}\xspace}
\newcommand{\teq}{\approx}
\newcommand{\tneq}{\not\teq}
\newcommand{\rem}[1]{\textcolor{red}{[#1]}}
\newcommand{\tester}[1]{is\text{-} #1}
\newcommand{\ror}{\quad \parallel \quad}
\newcommand{\tpath}[2]{\mathcal{P}_{ #2 \rightarrow \_ }( #1 )}
\newcommand{\ttpath}[3]{\mathcal{P}_{ #2 \rightarrow #3 }( #1 )}
\newcommand{\ec}[1]{ [ #1 ] }

% change?
\newcommand{\thD}{T_{D}}

%%% For final version as well?
\usepackage[
   a4paper,
   pdftex,
   pdftitle={A Decision Procedure for (Co)datatypes in SMT Solvers},
   pdfauthor={Andrew J. Reynolds and Jasmin Christian Blanchette},
   pdfkeywords={},
   pdfborder={0 0 0},
   draft=false,
   bookmarksnumbered,
   bookmarks,
   bookmarksdepth=2,
   bookmarksopenlevel=2,
   bookmarksopen]{hyperref}

\urlstyle{ttstyle}

\global\def\figurename{Figure}

\DeclareSymbolFont{letters}{OML}{txmi}{m}{it}

%%% REMOVE BEFORE SUBMITTING ABSOLUTELY FINAL VERSION
\makeatletter
\ps@myheadings
\makeatother

\include{defs}

\hyphenation{data-type data-types co-data-type co-data-types}

\begin{document}

\title{A Decision Procedure for (Co)datatypes in SMT Solvers}

\author {Andrew J. Reynolds\inst{1} \and Jasmin Christian Blanchette\inst{2,3}}
\authorrunning {A. J. Reynolds \and J. C. Blanchette}
\institute{
\'Ecole Polytechnique F\'ed\'erale de Lausanne (EPFL), Switzerland
\and
Inria Nancy \& LORIA, Villers-l\`es-Nancy, France
\and
Max-Planck-Institut f\"ur Informatik, Saarbr\"ucken, Germany
}

\maketitle

\begin{abstract}
Codatatypes naturally capture potentially infinite data structures and
processes. We introduce a decision procedure that combines reasoning about
datatypes and codatatypes. The dual of the acyclicity rule for datatypes is a
bisimilarity rule that identifies observationally equal, possibly cyclic values.
The procedure is complete for the universal fragment and is compatible with the
Nelson--Oppen method. It has been implemented in the latest version of CVC4, a
modern SMT solver. An evaluation based on problems generated from Isabelle
theories demonstrates the potential of the procedure for both proving and model
finding.
\end{abstract}

%% The institutions above shouldn't count as footnotes
\setcounter{footnote}{0}

\section{Introduction}
\label{sec:introduction}

Blah.

  * briefly: datatypes and why they are useful
    * Hoare's recursive data structures
    * comparatively easy to reason about and automate
    * common in practice, esp. in computer science applications

    (terminology: freely-generated, inductive, algebraic, ..., sometimes
    with different meanings; we'll clarify below what we use)

  * less briefly: codatatypes and why they are useful
    * in Agda, Coq, Matita -- recently also in Isabelle/HOL
    * but not in SMT-LIB (2.5?)

  * single decision procedure for datatypes and codatatypes
  * datatypes are implementation following the lines of Barrett et al.
  * codatatypes were added later, motivated by the use of SMT solvers as
    backends to proof assistants (more specifically, CVC4 to Isabelle/HOL)

  * setting (Section~\ref{sec:theory-of-co-datatypes}):
    * universal formulas
    * many-sorted logic
    * mutually (co)recursive types with constructors, selectors, and
      discriminators

  * codatatypes: from a theoretical and implementational point of view, like
      datatypes but:
    * codatatypes are never empty (e.g. finite streams are rejected)
    * no acyclicity (e.g. xs = lcons(0, xs) is satisfiable)
    * instead: bisimilarity check
    * (also: ``enumeration'', e.g. of streams)

  * motivation:
    * acyclicity and bisimilarity cannot be axiomatized, so they really belong in
      a decision procedure
    * other properties can be done more efficiently by a decision procedure

  * consider a natural fragment---datatypes as supported in modern SMT solvers
    and the SMT-LIB 2 standard, and codatatypes as their duals
    * mutual recursion, but no polymorphism, nested recursion

  * decision procedure is described abstractly as a calculus
    (Section~\ref{sec:the-calculus})
    * includes rewriting
    * and inferences

  * integrated with Nelson-Oppen

  * implemented in CVC4 as rewriting and a theory solver
    (\ref{sec:the-theory-solver})
    * precise strategy for applying inferences
    * about 2000 lines of code, among which 1600 are shared between datatypes
      and codatatypes

  * useful both for proving and for model finding
    * in particular, acyclicity and bisimilarity are necessary for some proofs
      (and cannot be axiomatized finitely)
    * and for model finding, without them we quickly get spurious models
    * explain how finite model finding works

%\ref{sec:examples}

  * benchmarking is often an issue -- esp. codatatypes
  * the decision procedure is evaluated on two sets of benchmarks
    (Section~\ref{sec:experimental-results}):
    * first set: hand-crafted examples
    * second set: generated from Isabelle theories using the Sledgehammer tool

Polymorphic types, nested (co)recursion, and datatype--codatatype mixtures fall

\paragraph{Related Work.}

    * point to Barrett et al. for SMT datatypes
      * about their own work, they say: "our focus is on generality and
        efficiency rather than immediacy of implementation"
      * (deal more directly with finite sorts than Barrett et al., Section 6.1)
    * additional ones since then (e.g. strings?)
    * anything about codatatypes?
      * proof assistants like Agda, Coq, etc. have them
      * Dafny, CoALP
      * also a lot of theoretical research, some of which is loosely connected,
        e.g. decision procedure for corecursive functions (Henning in Nijmegen)

    * ODDITY: Oppen 1980: single-constructor, recursive -- infinite values?

\paragraph{Conventions.}

* types are simply atomic sorts, with no structure, and interpreted by nonempty
  domains

* although nothing prevents composing the decision procedure with theories
  providing polymorphic types (parametric sorts), such as the theory of arrays

* $\sigma, \tau$ range over types---whether (co)datatypes or uninterpreted types
* $\delta$ range over (co)datatypes

* use sans-serif for function symbols (e.g., $\const{f}$) to distinguish them
from variables (e.g., $x$).

* function symbols are accompanied by a type signature, e.g. $\const{f} : \sigma_1 \times \cdots \times \sigma_n \to
\sigma$ indicates

* don't distinguish between constants and function symbols
  a constant is merely the case $n = 0$ of a function $f : 

\section{Theory of (Co)datatypes}
\label{sec:theory-of-co-datatypes}

\newcommand\keyw[1]{\textbf{#1}}
\newcommand\const[1]{\textsf{#1}}
\newcommand\ty[1]{\textit{#1}}

A signature consists of:
  * set of plain types, which can be interpreted or uninterpreted
    * must contain the distinguished \ty{bool} type of Booleans
  * set of function symbols with argument and return types
  * list of codatatype specifications, described below

A (co)datatype specification consists of $l$~mutually recursive types which are
either all datatypes or all codatatypes. Each datatype $\delta$ is equipped by
$m \ge 1$ constructors, and each constructor for $\delta$ takes zero or more
arguments and returns a $\delta$ value. The argument types must be either
plain, be or be one of the newly introduced (co)datatypes. To every
argument corresponds a selector. The introduced names for the (co)datatypes, the
constructors, and the selectors must be distinct and different from already
introduced ones. Schematically:
%
\[
\begin{aligned}[t]
(\keyw{co})\keyw{datatype}\;\,
  \delta_1 & {}=\, \const{C}_{11}(\bigl[\const{s}_{111}{:}\bigr]\; \sigma_{111}, \,\ldots,\, \bigl[\const{s}_{11n_{11}}{:}\bigr]\; \sigma_{11n_{11}}) & \\
           & {}\;\phantom{=\,}\;{} \smash{\,\,\,\vdots} \\[-\jot] % {}\;\phantom{=}\llap{\ensuremath{\mid}}\; \cdots \\
           & {}\;\phantom{=\,}\llap{\ensuremath{\,\mid\,}}\; \const{C}_{1m}(\bigl[\const{s}_{1m1}{:}\bigr]\; \sigma_{1m1}, \,\ldots,\, \big[\const{s}_{1mn_{1m}}{:}\big]\; \sigma_{1mn_{1m}}) \\[-1\jot]
   \smash{\vdots\,\,\,} \\[-1\jot]
  \keyw{and}\; \,\delta_l & =\, \ldots
\end{aligned}
\]
%
with
$\const{C}_{ij} : \sigma_{ij1}\times\cdots\times\sigma_{ijk_{ij}} \to \delta_i$
and $\const{s}_{ijk} : \delta_i \to \sigma_{ijk}$. Defaults are assumed for
the selector names if they are omitted.

Polymorphic types, nested (co)recursion, and datatype--codatatype mixtures fall
outside this fragment. For example, the specification
\[\begin{aligned}[t]
      \keyw{datatype}\;\, \ty{tree} & \,=\, \const{Node}(\ty{int},\, \ty{forest}) \\[-\jot]
      \keyw{and}\;\, \ty{forest} & \,=\, \const{FNil} \,\mid\, \const{FCons}(\ty{tree},\, \ty{forest})
\end{aligned}
\]
is supported, whereas
\[\begin{aligned}[t]
      \keyw{codatatype}\; \,\ty{llist}(\alpha) & \,=\, \const{LNil} \,\mid\, \const{LCons}(\alpha,\, \ty{llist}(\alpha)) \\[-.5\jot]
      \keyw{datatype}\;\, \ty{tree} & \,=\, \const{Node}(\ty{int},\, \ty{llist}(\ty{tree}))
\end{aligned}
\]
is beyond the fragment considered here. In principle, rank-1 (top-level)
polymorphism would be easy to support; nesting datatypes inside datatypes,
and likewise for codatatypes, can be reduced to the mutual case. So the only
genuinely interesting cases missing are mixed nested (co)recursion
(as in the \ty{tree} example above) as well as (co)recursion through a
non-(co)datatype (both of which do make sense \cite{blanchette-et-al-2014-codata}).


  * initial algebra
    * ``no junk, no confusion''
    * initial algebra ``exists'' only if well-founded
      otherwise it would be empty, which is disallowed by most formulations of
      first-order logic (including CVC4 and other SMT solvers)
      and higher-order logic (including Isabelle/HOL)

  * final coalgebra
    * this time, no condition: always exists
    e.g. the specification

      codatatype x = X x

    gives rise to a singleton type {X (X (X ...))}.

  * discriminators/selectors for initial algebras
  * constructors for final coalgebras

  * Introduce the discriminators already here.

  * how to deal with "wrong" selectors, e.g.
        hd(nil1) = hd(nil2)?
      * leave them unspecified; hence hd(nil1) = hd(nil2) in some models,
        and not in other models

  * ODDITY: Barrett et al. overspecify things (not good w.r.t. SMT-LIB 2, or
    other solvers, e.g., Z3)

  * axiomatically
    * injectivity
      distinctness
      exhaustiveness
    * datatypes:
      * induction axiom (schema)
        * consequence: no infinite objects (in particular, no cyclic objects)

      * when looking at the universal ground (?) theory:
        enough to consider acyclicity -- no way to specify infinite objects
        otherwise

    * codatatypes:
      * coinduction axiom (schema)
        * consequence: infinite objects are allowed, but
          two objects yielding the same observations must be equal

      * again: when looking at the universal ground (?) theory, enough to
        consider bisimilarity/bisimulation

\section{The Calculus}
\label{sec:the-calculus}

  * SMT background

  * Rewriter
  * Actual calculus

  * Correctness

\rem{Discuss signature $\Sigma$, theory $\thD$}
This section presents a calculus for determining the satisfiability of conjunctions of $\thD$-constraints.

Our calculus consists of derivation rules that operate on a set $\Ec$ of equalities and disequalities between $\Sigma$-terms.
We will write $\tEc$ to denote the set of $\Sigma$-terms occurring in $\Ec$.
We will commonly denote tuples of terms $( t_1, \ldots, t_n )$ in bold font, as $\vec t$.
We assume that all $\Sigma$-terms in $\Ec$ are \emph{normalized}, meaning that all subterms of the form $s^i_j( \const{C}_j( \vec t ) )$
are replaced by $t_i$, and moreover assume that all additional constraints added to $\Ec$ are normalized in this manner.

\begin{figure}[t]
\centering
\begin{tabular}{c}
\rn{Refl}
\(
\inferrule{
  t \in \tEc
}{
  \Ec := \Ec, t \teq t
}
\)
\qquad
\rn{Symm}
\(
\inferrule{
 t_1 \teq t_2 \in \Ec
}{
 \Ec := \Ec, t_2 \teq t_1
}
\)
\qquad
\rn{Conflict}
\(
\inferrule{
  t \teq u, t \tneq u \in \Ec
}{
  \bot
}
\)
\\[3.7ex]
\rn{Trans}
\(
\inferrule{
  t_1 \teq t_2, t_2 \teq t_3 \in \Ec
}{
  \Ec := \Ec, t_1 \teq t_3
}
\)
\qquad
\rn{Cong} 
\(
\inferrule{
  \vec t \teq \vec u \in \Ec \quad f( \vec t ), f( \vec u ) \in \tEc
}{
  \Ec := \Ec, f( \vec t ) \teq f( \vec u )
}
\)
\\[3.7ex]
\rn{Unify$_1$} 
\(
\inferrule{
  \const{C}_1( \vec t ) \teq \const{C}_1( \vec u ) \in \Ec
}{
  \Ec := \Ec, \vec t \teq \vec u
}
\)
\qquad
\rn{Unify$_2$} 
\(
\inferrule{
  \const{C}_1( \vec t ) \teq \const{C}_2( \vec u ) \in \Ec
}{
  \bot
}
\)
\end{tabular}
\caption{Rules for bidirectional closure.
}
\label{fig:cc-rules}
\end{figure}

We present the calculus in three phases, shown in Figures~\ref{fig:cc-rules},~\ref{fig:ab-rules}, and~\ref{fig:split-rule}.
Following the conventions from~\cite{}, 
the derivation rules of our calculus are given in \emph{guarded assignment form},
where a rule can be applied to $\Ec$ if it meets all of the specified preconditions for $\Ec$.
The conclusion of a rule either describes equalities to be added to $\Ec$ (in which case we will call an application of it to be \emph{non-terminal}),
or is $\bot$ (in which case we will call an application of it to be \emph{terminal}).
A rule may have multiple conclusions separated by $\parallel$, which denotes a non-deterministic branching.
An application of a rule is \emph{redundant} if it is non-terminal and at least one branch in its conclusion does not add a new equality to $\Ec$.

First, Figure~\ref{fig:cc-rules} gives the rules for constructing the bidirectional closure of $\Ec$.
The rules \rn{Refl}, \rn{Symm}, \rn{Trans}, and \rn{Cong} together compute the (upwards) congruence closure,
after which a conflict may be recognized by \rn{Conflict} when an inconsistency is found.
The rules \rn{Unify$_1$} and \rn{Unify$_2$} together compute (downwards) unification,
where additional equalities are inferred based on the injectivity of constructors (by \rn{Unify$_1$}),
and failures to unify equivalent terms are recognized (by \rn{Unify$_2$}).

Second, when applying the rules in Figure~\ref{fig:ab-rules}, 
we assume that $\Ec$ is saturated with respect to the rules in Figure~\ref{fig:cc-rules}, that is,
no non-redudant application of a rule can be applied to $\Ec$.
In this case, it is easy to see that $\Ec$ induces an equivalence relation over $\tEc$ such that two terms $t_1$ and $t_2$ are equivalent if and only if $t_1 \teq t_2 \in \Ec$.
Thus, we will in the following consider $\Ec$ as a set of equivalence classes of terms. 
For term $t \in \tEc$, we will write $\ec{t}$ to denote the equivalence class in $\Ec$ that containing $t$.

To explain the rules in Figure~\ref{fig:ab-rules}, we introduce the following notions.
First, an edge $\ec{t_1} \rightarrow^{C}_n \ec{t_2}$ is a transition between two equivalence classes $\ec{t_1}$ and $\ec{t_2}$ 
(which we will call its \emph{source} and \emph{destination} respectively),
labeled by a constructor $C$ and integer $n$.
We say that edge $\ec{t_1} \rightarrow^{C}_n \ec{t_2}$ is \emph{induced by $\Ec$} if and only if $C( \vec u ) \in \ec{t_1}$ for some $\vec u$ and $\ec{t_2} = \ec{u_n}$.
A \emph{path} $p$ is a non-empty ordered list of edges $e_1, \ldots e_n$ such that the destination of $e_i$ is the source of $e_{i+1}$ for $i = 1, \ldots (n-1)$,
and the sources of $e_1, \ldots, e_n$ are distinct.
We say that path $p$ is \emph{induced by $\Ec$} if and only if each of its edges are induced by $\Ec$.
Notice that since $\Ec$ contains a finite set of equivalence classes, all paths induced by $\Ec$ have finite length.
We call the source of a path is the source of its first edge, and the destination of a path is the destination of its last edge.
The set $\ttpath{\Ec}{\ec{t_1}}{\ec{t_2}}$ is the smallest set containing all paths with source $\ec{t_1}$ and destination $\ec{t_2}$ that are induced by $\Ec$.
The set $\tpath{\Ec}{\ec{t_1}}$ is the union of $\ttpath{\Ec}{\ec{t_1}}{\ec{t_2}}$ for all $t_2 \in \tEc$.

\begin{figure}[t]
\centering
\begin{tabular}{c}
\rn{Acyclic}
\(
\inferrule{
  t : \tau \text{ inductive } 
  \quad
  p \in \ttpath{\Ec}{\ec{t}}{\ec{t}}
}{
  \bot
}
\)
\\[3.7ex]
\rn{Bisimilar}
\(
\inferrule{
 t_1, t_2 : \tau \text{ co-inductive }
  \quad
 \exists \sigma. p \sigma \in \tpath{\Ec}{\ec{t_1}} \text{ for each } p \in \tpath{\Ec}{\ec{t_2}}
}{
 \Ec := \Ec, t_1 \teq t_2
}
\)
\end{tabular}
\caption{Rules for acyclicity and bisimilarity.
}
\label{fig:ab-rules}
\end{figure}

\rem{Change notation for inductive/co-inductive.}

\begin{figure}[t]
\centering
\begin{tabular}{c}
\rn{Split} 
\(
\inferrule{
  s^i_j( t ) \in \tEc, \text{ or } t : \tau \text{ finite }
}{
  \Ec := \Ec, \tester{\const{C}_1}( t ) \ror \ldots \ror \Ec := \Ec, \tester{\const{C}_n}( t ) 
}
\)
\end{tabular}
\caption{Rule for splitting.  We write $\tester{\const{C}_i}( t )$ as shorthand for the equality $t \teq \const{C}_i( s^1_i( t ), \ldots, s^n_i( t ) )$.
}
\label{fig:split-rule}
\end{figure}




A \emph{derivation tree} is a tree whose nodes are sets of equalities, where non-root nodes are obtained by a non-redundant application of a derivation rule to its parent node.
A derivation tree is \emph{closed} if all of its leaf nodes are $\bot$.
A node is \emph{saturated} if no non-redundant application of a rule can be applied to it.
  

\subsection{Correctness}

\begin{lemma}[Refutation Soundness]
If there exists a closed derivation tree with root node $\Ec$, then $\Ec$ is unsatisfiable in $\thD$.
\end{lemma}

\begin{lemma}[Solution Soundness]
If there exists a derivation tree containing a saturated node with root node $\Ec$, then $\Ec$ is satisfiable in $\thD$.
\end{lemma}

\begin{lemma}[Termination]
All derivation trees are finite.
\end{lemma}

\rem{Thus, sound and complete.}
  
\section{The Theory Solver}
\label{sec:the-theory-solver}

  * Strategies
  * Implementation
    * what is an SMT theory solver
    * cooperation with Nelson-Oppen / integration into SMT solver
    * "mu" stuff
    * no "internal search"
  * Enumerator?
    * for model generation

%\section{Examples}
%\label{sec:examples}

\section{Experimental Results}
\label{sec:experimental-results}

  * Constructed examples
    * proving
    * model finding?

  * Isabelle benchmarks


\section{Conclusion}
\label{sec:conclusion}

Future work:

  * more evaluation
  * recursive and corecursive functions
    (and rewriting)

\def\ackname{Acknowledgment}
\paragraph{\ackname.}

Clark Barrett and Cesare Tinelli.

Bosses: Viktor Kuncak, Tobias Nipkow, and Stephan Merz.

The research was partially supported by the Deutsche
Forschungs\-gemein\-schaft (DFG) project
\relax{Hardening the Hammer} (grant Ni\,491\slash 14-1).

\bibliographystyle{splncs03}
\bibliography{bib}{}

\end{document}
