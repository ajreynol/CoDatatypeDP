%envcountsect,
\documentclass[a4paper,oribibl,envcountsame,draft]{llncs}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{arydshln}
\usepackage[scaled=.82]{beramono}
\usepackage{booktabs}
\usepackage{bussproofs}
\usepackage{calc}
\usepackage{cite}
\usepackage{mathptmx}
%\usepackage{txfonts}
%\usepackage{mathrsfs}
%\usepackage{pifont}
%\usepackage{smallcap}
\usepackage{mathpartir} 
\usepackage{stmaryrd}
\usepackage{subfigure}
\usepackage[usenames]{color}
%\usepackage{graphicx}
%\usepackage{newcent}
\usepackage{textcomp}
%\usepackage{tipa}
\usepackage{units}
\usepackage{url}
\usepackage{version}
\usepackage[all]{xy}

\DeclareFontFamily{OT1}{pzc}{}
\DeclareFontShape{OT1}{pzc}{m}{it}{<-> s * [1.10] pzcmi7t}{}
\DeclareMathAlphabet{\mathscr}{OT1}{pzc}{m}{it}

\DeclareMathAlphabet{\mathcal}{OT1}{pzc}{m}{it}

\renewcommand{\vec}[1]{\boldsymbol{#1}}
\newcommand{\Ec}{\mathsf{E}}
\newcommand{\tEc}{\mathcal{T}(\Ec)}
\newcommand{\rn}[1]{\textsf{\small #1}}
\newcommand{\cvc}{\textsc{cvc}{\small 4}\xspace}
\newcommand{\teq}{\approx}
\newcommand{\tneq}{\not\teq}
\newcommand{\rem}[1]{\textcolor{red}{[#1]}}
\newcommand{\tester}[1]{is\text{-} #1}
\newcommand{\ror}{\quad \parallel \quad}
\newcommand{\tpath}[2]{\mathcal{P}_{ #2 \rightarrow \_ }( #1 )}
\newcommand{\ttpath}[3]{\mathcal{P}_{ #2 \rightarrow #3 }( #1 )}
\newcommand{\ec}[1]{ [ #1 ] }

% change?
\newcommand{\thD}{T_{D}}

%%% For final version as well?
\usepackage[
   a4paper,
   pdftex,
   pdftitle={A Decision Procedure for (Co)datatypes in SMT Solvers},
   pdfauthor={Andrew J. Reynolds and Jasmin Christian Blanchette},
   pdfkeywords={},
   pdfborder={0 0 0},
   draft=false,
   bookmarksnumbered,
   bookmarks,
   bookmarksdepth=2,
   bookmarksopenlevel=2,
   bookmarksopen]{hyperref}

\urlstyle{ttstyle}

\global\def\figurename{Figure}

\DeclareSymbolFont{letters}{OML}{txmi}{m}{it}

%%% REMOVE BEFORE SUBMITTING ABSOLUTELY FINAL VERSION
\makeatletter
\ps@myheadings
\makeatother

\include{defs}

\begin{document}

%\title{Mechanising the Metatheory of %(Many-Sorted)
%  First-Order Logic}
%\subtitle{Infrastructure and Application to Sort Encodings}
%\title{A Mechanised Metatheory of First-Order Logic \\
%  and Its Application to Sort Erasure}
\title{A Decision Procedure for (Co)datatypes in SMT Solvers}

\author {Andrew J. Reynolds\inst{1} \and Jasmin Christian Blanchette\inst{2,3}}
\authorrunning {A. J. Reynolds \and J. C. Blanchette}
\institute{
\'Ecole Polytechnique F\'ed\'erale de Lausanne (EPFL), Switzerland
\and
Inria \& LORIA, Villers-l\`es-Nancy, France \\
Max-Planck-Institut f\"ur Informatik, Saarbr\"ucken, Germany
}

\maketitle

\begin{abstract}
Blah.
\end{abstract}

%% The institutions above shouldn't count as footnotes
\setcounter{footnote}{0}

\section{Introduction}
\label{sec:introduction}

Blah.

  * briefly: datatypes and why they are useful
    (terminology: freely-generated, inductive, algebraic, ..., sometimes
    with different meanings; we'll clarify below)
    * Hoare's recursive data structures
    * comparatively easy to reason about and automate
    * common in practice, esp. in computer science applications

  * less briefly: codatatypes and why they are useful
    * in Agda, Coq, Matita -- recently also in Isabelle/HOL
    * but not in SMT-LIB (2.5?)

  * single decision procedure for datatypes and codatatypes
  * datatypes are implementation following the lines of Barrett et al.
  * codatatypes were added later, motivated by the use of SMT solvers as
    backends to proof assistants (more specifically, CVC4 to Isabelle/HOL)

  * setting (Section~\ref{sec:theory-of-co-datatypes}):
    * universal formulas
    * many-sorted logic
    * mutually (co)recursive types with constructors, selectors, and
      discriminators

  * codatatypes: from a theoretical and implementational point of view, like
      datatypes but:
    * codatatypes are never empty (e.g. finite streams are rejected)
    * no acyclicity (e.g. xs = lcons(0, xs) is satisfiable)
    * instead: bisimilarity check
    * (also: ``enumeration'', e.g. of streams)

  * motivation:
    * acyclicity and bisimilarity cannot be axiomatized, so they really belong in
      a decision procedure
    * other properties can be done more efficiently by a decision procedure

  * decision procedure is described abstractly as a calculus
    (Section~\ref{sec:the-calculus})
    * includes rewriting
    * and inferences

  * integrated with Nelson-Oppen

  * implemented in CVC4 as rewriting and a theory solver
    (\ref{sec:the-theory-solver})
    * precise strategy for applying inferences
    * about 2000 lines of code, among which 1600 are shared between datatypes
      and codatatypes

  * useful both for proving and for model finding
    * in particular, acyclicity and bisimilarity are necessary for some proofs
      (and cannot be axiomatized finitely)
    * and for model finding, without them we quickly get spurious models

%\ref{sec:examples}

  * benchmarking is often an issue -- esp. codatatypes
  * the decision procedure is evaluated on two sets of benchmarks
    (Section~\ref{sec:experimental-results}):
    * first set: hand-crafted examples
    * second set: generated from Isabelle theories using the Sledgehammer tool

\paragraph{Related Work.}

    * point to Barrett et al. for SMT datatypes
      * about their own work, they say: "our focus is on generality and
        efficiency rather than immediacy of implementation"
      * (deal more directly with finite sorts than Barrett et al., Section 6.1)
    * additional ones since then (e.g. strings?)
    * anything about codatatypes?
      * proof assistants like Agda, Coq, etc. have them
      * Dafny, CoALP
      * also a lot of theoretical research, some of which is loosely connected,
        e.g. decision procedure for corecursive functions (Henning in Nijmegen)

    * ODDITY: Oppen 1980: single-constructor, recursive -- infinite values?

\section{Theory of (Co)datatypes}
\label{sec:theory-of-co-datatypes}

  * (co)datatype specifications:
    * N mutually recursive types (datatypes or codatatypes -- no mixture)
    * list of n constructors (n >= 1)
    * each constructor has m arguments (m >= 0)
    * each argument has a sort, which may be 

  * don't consider mixtures (co)datatypes (cf. Agda), nor polymorphic types, nor
    is it possible to do any nesting; e.g. this is outside our scope:

      datatype tree = Node Int (Array tree)

  * initial algebra
    * ``no junk, no confusion''
    * initial algebra ``exists'' only if well-founded
      otherwise it would be empty, which is disallowed by most formulations of
      first-order logic (including CVC4 and other SMT solvers)
      and higher-order logic (including Isabelle/HOL)

  * final coalgebra
    * this time, no condition: always exists
    e.g. the specification

      codatatype x = X x

    gives rise to a singleton type {X (X (X ...))}.

  * discriminators/selectors for initial algebras
  * constructors for final coalgebras

  * how to deal with "wrong" selectors, e.g.
        hd(nil1) = hd(nil2)?
      * leave them unspecified; hence hd(nil1) = hd(nil2) in some models,
        and not in other models

  * ODDITY: Barrett et al. overspecify things (not good w.r.t. SMT-LIB 2, or
    other solvers, e.g., Z3)

  * axiomatically
    * injectivity
      distinctness
      exhaustiveness
    * datatypes:
      * induction axiom (schema)
        * consequence: no infinite objects (in particular, no cyclic objects)

      * when looking at the universal ground (?) theory:
        enough to consider acyclicity -- no way to specify infinite objects
        otherwise

    * codatatypes:
      * coinduction axiom (schema)
        * consequence: infinite objects are allowed, but
          two objects yielding the same observations must be equal

      * again: when looking at the universal ground (?) theory, enough to
        consider bisimilarity/bisimulation

\section{The Calculus}
\label{sec:the-calculus}

  * SMT background

  * Rewriter
  * Actual calculus

  * Correctness

\rem{Discuss signature $\Sigma$, theory $\thD$}
This section presents a calculus for determining the satisfiability of conjunctions of $\thD$-constraints.

Our calculus consists of derivation rules that operate on a set $\Ec$ of equalities and disequalities between $\Sigma$-terms.
We will write $\tEc$ to denote the set of $\Sigma$-terms occurring in $\Ec$.
We will commonly denote tuples of terms $( t_1, \ldots, t_n )$ in bold font, as $\vec t$.
We assume that all $\Sigma$-terms in $\Ec$ are \emph{normalized}, meaning that all subterms of the form $s^i_j( C_j( \vec t ) )$
are replaced by $t_i$, and moreover assume that all additional constraints added to $\Ec$ are normalized in this manner.

\begin{figure}[t]
\centering
\begin{tabular}{c}
\rn{Refl}
\(
\inferrule{
  t \in \tEc
}{
  \Ec := \Ec, t \teq t
}
\)
\qquad
\rn{Symm}
\(
\inferrule{
 t_1 \teq t_2 \in \Ec
}{
 \Ec := \Ec, t_2 \teq t_1
}
\)
\qquad
\rn{Conflict}
\(
\inferrule{
  t \teq u, t \tneq u \in \Ec
}{
  \bot
}
\)
\\[3.7ex]
\rn{Trans}
\(
\inferrule{
  t_1 \teq t_2, t_2 \teq t_3 \in \Ec
}{
  \Ec := \Ec, t_1 \teq t_3
}
\)
\qquad
\rn{Cong} 
\(
\inferrule{
  \vec t \teq \vec u \in \Ec \quad f( \vec t ), f( \vec u ) \in \tEc
}{
  \Ec := \Ec, f( \vec t ) \teq f( \vec u )
}
\)
\\[3.7ex]
\rn{Unify$_1$} 
\(
\inferrule{
  C_1( \vec t ) \teq C_1( \vec u ) \in \Ec
}{
  \Ec := \Ec, \vec t \teq \vec u
}
\)
\qquad
\rn{Unify$_2$} 
\(
\inferrule{
  C_1( \vec t ) \teq C_2( \vec u ) \in \Ec
}{
  \bot
}
\)
\end{tabular}
\caption{Rules for bidirectional closure.
}
\label{fig:cc-rules}
\end{figure}

We present the calculus in three phases, shown in Figures~\ref{fig:cc-rules},~\ref{fig:ab-rules}, and~\ref{fig:split-rule}.
Following the conventions from~\cite{}, 
the derivation rules of our calculus are given in \emph{guarded assignment form},
where a rule can be applied to $\Ec$ if it meets all of the specified preconditions for $\Ec$.
The conclusion of a rule either describes equalities to be added to $\Ec$ (in which case we will call an application of it to be \emph{non-terminal}),
or is $\bot$ (in which case we will call an application of it to be \emph{terminal}).
A rule may have multiple conclusions separated by $\parallel$, which denotes a non-deterministic branching.
An application of a rule is \emph{redundant} if it is non-terminal and at least one branch in its conclusion does not add a new equality to $\Ec$.

First, Figure~\ref{fig:cc-rules} gives the rules for constructing the bidirectional closure of $\Ec$.
The rules \rn{Refl}, \rn{Symm}, \rn{Trans}, and \rn{Cong} together compute the (upwards) congruence closure,
after which a conflict may be recognized by \rn{Conflict} when an inconsistency is found.
The rules \rn{Unify$_1$} and \rn{Unify$_2$} together compute (downwards) unification,
where additional equalities are inferred based on the injectivity of constructors (by \rn{Unify$_1$}),
and failures to unify equivalent terms are recognized (by \rn{Unify$_2$}).

Second, when applying the rules in Figure~\ref{fig:ab-rules}, 
we assume that $\Ec$ is saturated with respect to the rules in Figure~\ref{fig:cc-rules}, that is,
no non-redudant application of a rule can be applied to $\Ec$.
In this case, it is easy to see that $\Ec$ induces an equivalence relation over $\tEc$ such that two terms $t_1$ and $t_2$ are equivalent if and only if $t_1 \teq t_2 \in \Ec$.
Thus, we will in the following consider $\Ec$ as a set of equivalence classes of terms. 
For term $t \in \tEc$, we will write $\ec{t}$ to denote the equivalence class in $\Ec$ that containing $t$.

To explain the rules in Figure~\ref{fig:ab-rules}, we introduce the following notions.
First, an edge $\ec{t_1} \rightarrow^{C}_n \ec{t_2}$ is a transition between two equivalence classes $\ec{t_1}$ and $\ec{t_2}$ 
(which we will call its \emph{source} and \emph{destination} respectively),
labelled by a constructor $C$ and integer $n$.
We say that edge $\ec{t_1} \rightarrow^{C}_n \ec{t_2}$ is \emph{induced by $\Ec$} if and only if $C( \vec u ) \in \ec{t_1}$ for some $\vec u$ and $\ec{t_2} = \ec{u_n}$.
A \emph{path} $p$ is a non-empty ordered list of edges $e_1, \ldots e_n$ such that the destination of $e_i$ is the source of $e_{i+1}$ for $i = 1, \ldots (n-1)$,
and the sources of $e_1, \ldots, e_n$ are distinct.
We say that path $p$ is \emph{induced by $\Ec$} if and only if each of its edges are induced by $\Ec$.
Notice that since $\Ec$ contains a finite set of equivalence classes, all paths induced by $\Ec$ have finite length.
We call the source of a path is the source of its first edge, and the destination of a path is the destination of its last edge.
The set $\ttpath{\Ec}{\ec{t_1}}{\ec{t_2}}$ is the smallest set containing all paths with source $\ec{t_1}$ and destination $\ec{t_2}$ that are induced by $\Ec$.
The set $\tpath{\Ec}{\ec{t_1}}$ is the union of $\ttpath{\Ec}{\ec{t_1}}{\ec{t_2}}$ for all $t_2 \in \tEc$.

\begin{figure}[t]
\centering
\begin{tabular}{c}
\rn{Acyclic}
\(
\inferrule{
  t : \tau \text{ inductive } 
  \quad
  p \in \ttpath{\Ec}{\ec{t}}{\ec{t}}
}{
  \bot
}
\)
\\[3.7ex]
\rn{Bisimilar}
\(
\inferrule{
 t_1, t_2 : \tau \text{ co-inductive }
  \quad
 \exists \sigma. p \sigma \in \tpath{\Ec}{\ec{t_1}} \text{ for each } p \in \tpath{\Ec}{\ec{t_2}}
}{
 \Ec := \Ec, t_1 \teq t_2
}
\)
\end{tabular}
\caption{Rules for acyclicity and bisimilarity.
}
\label{fig:ab-rules}
\end{figure}

\rem{Change notation for inductive/co-inductive.}

\begin{figure}[t]
\centering
\begin{tabular}{c}
\rn{Split} 
\(
\inferrule{
  s^i_j( t ) \in \tEc, \text{ or } t : \tau \text{ finite }
}{
  \Ec := \Ec, \tester{C_1}( t ) \ror \ldots \ror \Ec := \Ec, \tester{C_n}( t ) 
}
\)
\end{tabular}
\caption{Rule for splitting.  We write $\tester{C_i}( t )$ as shorthand for the equality $t \teq C_i( s^1_i( t ), \ldots, s^n_i( t ) )$.
}
\label{fig:split-rule}
\end{figure}




A \emph{derivation tree} is a tree whose nodes are sets of equalities, where non-root nodes are obtained by a non-redundant application of a derivation rule to its parent node.
A derivation tree is \emph{closed} if all of its leaf nodes are $\bot$.
A node is \emph{saturated} if no non-redundant application of a rule can be applied to it.
  

\subsection{Correctness}

\begin{lemma}[Refutation Soundness]
If there exists a closed derivation tree with root node $\Ec$, then $\Ec$ is unsatisfiable in $\thD$.
\end{lemma}

\begin{lemma}[Solution Soundness]
If there exists a derivation tree containing a saturated node with root node $\Ec$, then $\Ec$ is satisfiable in $\thD$.
\end{lemma}

\begin{lemma}[Termination]
All derivation trees are finite.
\end{lemma}

\rem{Thus, sound and complete.}
  
\section{The Theory Solver}
\label{sec:the-theory-solver}

  * Strategies
  * Implementation
    * what is an SMT theory solver
    * cooperation with Nelson-Oppen / integration into SMT solver
    * "mu" stuff
    * no "internal search"
  * Enumerator?
    * for model generation

%\section{Examples}
%\label{sec:examples}

\section{Experimental Results}
\label{sec:experimental-results}

  * Constructed examples
  * Isabelle benchmarks

\section{Conclusion}
\label{sec:conclusion}

Future work:

  * more evaluation
  * recursive and corecursive functions
    (and rewriting)

\def\ackname{Acknowledgment}
\paragraph{\ackname.}

Clark Barrett and Cesare Tinelli.

Bosses: Viktor Kuncak, Tobias Nipkow, and Stephan Merz.

The research was partially supported by the Deutsche
Forschungs\-gemein\-schaft (DFG) project
\relax{Hardening the Hammer} (grant Ni\,491\slash 14-1).

\bibliographystyle{splncs03}
\bibliography{bib}{}

\end{document}
