----------------------- REVIEW 1 ---------------------
PAPER: 3
TITLE: A Decision Procedure for (Co)datatypes in SMT Solvers
AUTHORS: Andrew Reynolds and Jasmin Christian Blanchette

OVERALL EVALUATION: 2 (accept)
REVIEWER'S CONFIDENCE: 3 (medium)

----------- REVIEW -----------
This paper, as the authors acknowledge, is an extended version of
their previously published CADE-25 paper. Although the amount of new
material is not extraordinary, it is enough in my opinion: more
detailed proofs, some more background material, and a more detailed
description of how several things are implemented.

Not too many recent papers about decision procedures for datatypes
exist. Probably the most important one is the one by Barrett,
Shikanian and Tinelli, of which this submission can be seen as an
extension. However, codatatypes are included in the current work,
which makes the whole procedure much more involved. We want to remark
that there is an important lack of recent references about decision
procedures for codatatypes in the literature, which makes this
submission an important contribution.

The technical writing is very good, no typos have been noticed and
almost nothing can be said in order to improve the quality of the
proofs. Proofs seemed correct to me and I have noticed an effort by the
authors to make the proofs as understandable as possible. I found the
"Solution Soundness" proof hard to follow, but I cannot think of a
better way to improve it. Maybe taking a running example and showing
how J and A* are constructed might help and this is the only big
change I would suggest the authors to make.

Page 5, Induction: adding the range for $k$ and $i$ in the $\land$s
    might be helpful. The same applies to coinduction

Page 5, Coinduction: I would suggest to add parenthesis in order to
    improve the reading.

Page 7, Phase 2: there is a sequence of term1 != term2 != term3.
    How should the reader interpret this? Are all pairwise different?

Page 12, Lemma 2: who is $x$? Any variable? A concrete one?
    The same applies to $y$ in the second point.


----------------------- REVIEW 2 ---------------------
PAPER: 3
TITLE: A Decision Procedure for (Co)datatypes in SMT Solvers
AUTHORS: Andrew Reynolds and Jasmin Christian Blanchette

OVERALL EVALUATION: 2 (accept)
REVIEWER'S CONFIDENCE: 3 (medium)

----------- REVIEW -----------
The paper presents a decision procedure for (co)inductive datatypes in the
context of SMT. The proposed algorithm extends previous work [3] that handled
only datatypes, showing how to support also codatatypes, i.e. "datatypes"
which might not be well-founded. The key idea of the procedure is the use of
\mu-terms to denote infinite constructor terms with cyclic
values. Intuitively, \mu-terms are used as representatives of the equivalence
classes induced by the input constraints, so that an inconsistency is detected
when a datatype class has a cyclic \mu-term as a representative, and a
uniqueness constraint is asserted when two codatatype classes have two
\mu-terms that are \alpha-equivalent as representatives.

The paper is divided in three main parts. In the first, the decision procedure
is presented as a set of inference rules, that are proved to be sound and
complete. Interestingly, the completeness proof is constructive, i.e. the
authors show how to actually generate a model for the input constraints when
they are satisfiable. The proofs are quite technical at times, but I'm not
sure to what extent this can be avoided. Moreover, the examples provided help
the reader to follow.

In the second part of the paper, the authors describe how the procedure has
been implemented inside the CVC4 SMT solver. They show how the set of
inference rules is organized in a hierarchy of increasing cost, discussing a
strategy for deciding when to apply each of them. Pseudo-code is also given
showing the implementation of two of the key rules of the procedure, namely
the check for acyclicity in datatypes and that of uniqueness in codatatypes.

Finally, the last part of the paper is dedicated to an empirical evaluation of
the effectiveness of the procedure on problems generated by the Isabelle
theorem prover. The results show that the new decision procedure allows CVC4
to solve several benchmarks that could not be solved before (or that cannot be
solved by Z3, which is used for comparison).

The paper is very well-written, and the contribution is clear. Not only the
paper extends the procedure of [3] to handle codatatypes, but in my opinion
also the description of the datatype part given here is easier to follow than
[3]. As the authors point out, using \mu-terms allows to handle datatypes and
codatatypes in a uniform manner, and makes the algorithm simple to understand
(at least at the high level). Compared to the conference version, the amount
of new material added (full proofs, more details on (co)datatypes, extended
experimental evaluation, expanded description of the implementation) is enough
to justify a journal publication. Therefore, I recommend acceptance. I have
only a few minor remarks, reported below.

- the description of the induction and coinduction rule is currently quite
 dense, and not very easy to follow. The connectives in the rules range over
 several indices, and it is quite hard at the moment to keep track of all of
 them. I would ask the authors to:
 1. rewrite the rules by making the indices explicit
 2. provide a simple example of application of the rules for the benefit of
    the reader

- the procedure is complete only if all ordinary types have infinite
 cardinality. The paper observes that this is not a problem, because ordinary
 types with finite cardinality n can be viewed as datatypes with n
 constructors. I wonder how practical this is, especially in situations in
 which n is finite but large (e.g. bit-vectors). More specifically, it would
 be interesting to understand whether this is actually the strategy used in
 the implementation, or if instead some other "trick" is applied
 (e.g. similarly to what is done for improving the precision when solving
 quantified problems)

- regarding the integration into CDCL(T), it would be interesting to read more
 about the generation of explanations. In particular, does the procedure
 ensure that explanations are minimal/irredundant? If not, does this have an
 impact in practice? E.g. does it make sense to try to minimize the produced
 explanations, or would the cost outweigh the benefit? 

- Page 17: "By assuming ... infinite cardinality". I had to read the sentence
 a few times before realizing it was not a typo. Although I'm not a native
 English speaker, perhaps this could be rephrased, e.g. "Since it assumes
 that ... infinite cardinality, ".
 